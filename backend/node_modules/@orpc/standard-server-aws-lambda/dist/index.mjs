import { Buffer } from 'node:buffer';
import { runWithSpan, parseEmptyableJSON, toArray, once } from '@orpc/shared';
import { getFilenameFromContentDisposition, flattenHeader } from '@orpc/standard-server';
import { toNodeHttpBody, toAbortSignal } from '@orpc/standard-server-node';
export { toAbortSignal, toEventStream } from '@orpc/standard-server-node';
import { toEventIterator as toEventIterator$1 } from '@orpc/standard-server-fetch';

function toEventIterator(body, options = {}) {
  if (body === void 0) {
    return toEventIterator$1(null, options);
  }
  return toEventIterator$1(
    new ReadableStream({
      pull(controller) {
        controller.enqueue(body);
        controller.close();
      }
    }).pipeThrough(new TextEncoderStream()),
    options
  );
}

function toStandardBody(event, options = {}) {
  return runWithSpan({ name: "parse_standard_body", signal: options.signal }, async () => {
    const contentType = event.headers["content-type"];
    const contentDisposition = event.headers["content-disposition"];
    if (typeof contentDisposition === "string") {
      const fileName = getFilenameFromContentDisposition(contentDisposition) ?? "blob";
      return _parseAsFile(event.body, event.isBase64Encoded, fileName, contentType ?? "");
    }
    if (!contentType || contentType.startsWith("application/json")) {
      const text = _parseAsString(event.body, event.isBase64Encoded);
      return parseEmptyableJSON(text);
    }
    if (contentType.startsWith("multipart/form-data")) {
      return _parseAsFormData(event.body, event.isBase64Encoded, contentType);
    }
    if (contentType.startsWith("application/x-www-form-urlencoded")) {
      return new URLSearchParams(_parseAsString(event.body, event.isBase64Encoded));
    }
    if (contentType.startsWith("text/event-stream")) {
      return toEventIterator(_parseAsString(event.body, event.isBase64Encoded), options);
    }
    if (contentType.startsWith("text/plain")) {
      return _parseAsString(event.body, event.isBase64Encoded);
    }
    return _parseAsFile(event.body, event.isBase64Encoded, "blob", contentType);
  });
}
function toLambdaBody(standardBody, standardHeaders, options = {}) {
  standardHeaders = { ...standardHeaders };
  const body = toNodeHttpBody(standardBody, standardHeaders, options);
  return [body, standardHeaders];
}
function _parseAsFile(body, isBase64Encoded, fileName, contentType) {
  return new File(
    body === void 0 ? [] : [isBase64Encoded ? Buffer.from(body, "base64") : body],
    fileName,
    { type: contentType }
  );
}
function _parseAsString(body, isBase64Encoded) {
  return isBase64Encoded && body !== void 0 ? Buffer.from(body, "base64").toString() : body;
}
function _parseAsFormData(body, isBase64Encoded, contentType) {
  const blobPart = isBase64Encoded && body !== void 0 ? Buffer.from(body, "base64") : body;
  const response = new Response(blobPart, {
    headers: {
      "content-type": contentType
    }
  });
  return response.formData();
}

function toStandardHeaders(headers, cookies) {
  return {
    ...headers,
    "set-cookie": cookies
  };
}
function toLambdaHeaders(standard) {
  const headers = {};
  const setCookies = [];
  for (const key in standard) {
    const value = standard[key];
    if (value === void 0) {
      continue;
    }
    if (key === "set-cookie") {
      setCookies.push(...toArray(value));
    } else {
      headers[key] = flattenHeader(value);
    }
  }
  return [headers, setCookies];
}

function toStandardUrl(event) {
  return new URL(`https://${event.requestContext.domainName}${event.rawPath}?${event.rawQueryString}`);
}

function toStandardLazyRequest(event, responseStream) {
  const signal = toAbortSignal(responseStream);
  return {
    url: toStandardUrl(event),
    method: event.requestContext.http.method,
    headers: toStandardHeaders(event.headers, event.cookies),
    signal,
    body: once(() => toStandardBody(event, { signal }))
  };
}

function sendStandardResponse(responseStream, standardResponse, options = {}) {
  return new Promise((resolve, reject) => {
    responseStream.once("error", reject);
    responseStream.once("close", resolve);
    const [body, standardHeaders] = toLambdaBody(standardResponse.body, standardResponse.headers, options);
    const [headers, setCookies] = toLambdaHeaders(standardHeaders);
    globalThis.awslambda.HttpResponseStream.from(responseStream, {
      statusCode: standardResponse.status,
      headers,
      cookies: setCookies
    });
    if (body === void 0) {
      responseStream.end();
    } else if (typeof body === "string") {
      responseStream.write(body);
      responseStream.end();
    } else {
      responseStream.once("close", () => {
        if (!body.closed) {
          body.destroy(responseStream.errored ?? void 0);
        }
      });
      body.once("error", (error) => responseStream.destroy(error));
      body.pipe(responseStream);
    }
  });
}

export { sendStandardResponse, toEventIterator, toLambdaBody, toLambdaHeaders, toStandardBody, toStandardHeaders, toStandardLazyRequest, toStandardUrl };
