import { C as Context, R as Router } from '../../shared/server.B4BGqy3Y.mjs';
import { Interceptor, MaybeOptionalOptions } from '@orpc/shared';
import { ToFetchResponseOptions } from '@orpc/standard-server-fetch';
import { g as StandardHandlerPlugin, C as CompositeStandardHandlerPlugin, b as StandardHandleOptions, f as StandardHandler } from '../../shared/server.DBCUJijK.mjs';
import { F as FriendlyStandardHandleOptions } from '../../shared/server.CVKCo60T.mjs';
import { S as StandardRPCHandlerOptions } from '../../shared/server.Ck-gOLzq.mjs';
import '@orpc/client';
import '@orpc/contract';
import '@orpc/standard-server';
import '@orpc/client/standard';
import '../../shared/server.DzV1hr3z.mjs';

interface FetchHandlerPlugin<T extends Context> extends StandardHandlerPlugin<T> {
    initRuntimeAdapter?(options: FetchHandlerOptions<T>): void;
}
declare class CompositeFetchHandlerPlugin<T extends Context, TPlugin extends FetchHandlerPlugin<T>> extends CompositeStandardHandlerPlugin<T, TPlugin> implements FetchHandlerPlugin<T> {
    initRuntimeAdapter(options: FetchHandlerOptions<T>): void;
}

type FetchHandleResult = {
    matched: true;
    response: Response;
} | {
    matched: false;
    response: undefined;
};
interface FetchHandlerInterceptorOptions<T extends Context> extends StandardHandleOptions<T> {
    request: Request;
    toFetchResponseOptions: ToFetchResponseOptions;
}
interface FetchHandlerOptions<T extends Context> extends ToFetchResponseOptions {
    adapterInterceptors?: Interceptor<FetchHandlerInterceptorOptions<T>, Promise<FetchHandleResult>>[];
    plugins?: FetchHandlerPlugin<T>[];
}
declare class FetchHandler<T extends Context> {
    private readonly standardHandler;
    private readonly toFetchResponseOptions;
    private readonly adapterInterceptors;
    constructor(standardHandler: StandardHandler<T>, options?: NoInfer<FetchHandlerOptions<T>>);
    handle(request: Request, ...rest: MaybeOptionalOptions<FriendlyStandardHandleOptions<T>>): Promise<FetchHandleResult>;
}

interface BodyLimitPluginOptions {
    /**
     * The maximum size of the body in bytes.
     */
    maxBodySize: number;
}
/**
 * The Body Limit Plugin restricts the size of the request body for the Fetch Server.
 *
 * @see {@link https://orpc.unnoq.com/docs/plugins/body-limit Body Limit Plugin Docs}
 */
declare class BodyLimitPlugin<T extends Context> implements FetchHandlerPlugin<T> {
    private readonly maxBodySize;
    constructor(options: BodyLimitPluginOptions);
    initRuntimeAdapter(options: FetchHandlerOptions<T>): void;
}

/**
 * This plugin is heavily inspired by the [Hono Compression Plugin](https://github.com/honojs/hono/blob/main/src/middleware/compress/index.ts)
 */

declare const ORDERED_SUPPORTED_ENCODINGS: readonly ["gzip", "deflate"];
interface CompressionPluginOptions {
    /**
     * The compression schemes to use for response compression.
     * Schemes are prioritized by their order in this array and
     * only applied if the client supports them.
     *
     * @default ['gzip', 'deflate']
     */
    encodings?: readonly (typeof ORDERED_SUPPORTED_ENCODINGS)[number][];
    /**
     * The minimum response size in bytes required to trigger compression.
     * Responses smaller than this threshold will not be compressed to avoid overhead.
     * If the response size cannot be determined, compression will still be applied.
     *
     * @default 1024 (1KB)
     */
    threshold?: number;
    /**
     * Override the default content-type filter used to determine which responses should be compressed.
     *
     * @warning [Event Iterator](https://orpc.unnoq.com/docs/event-iterator) responses are never compressed, regardless of this filter's return value.
     * @default only responses with compressible content types are compressed.
     */
    filter?: (request: Request, response: Response) => boolean;
}
/**
 * The Compression Plugin adds response compression to the Fetch Server.
 * Build on top of [CompressionStream](https://developer.mozilla.org/en-US/docs/Web/API/CompressionStream)
 * You might need to polyfill it if your environment does not support it.
 *
 * @see {@link https://orpc.unnoq.com/docs/plugins/compression Compression Plugin Docs}
 */
declare class CompressionPlugin<T extends Context> implements FetchHandlerPlugin<T> {
    private readonly encodings;
    private readonly threshold;
    private readonly filter;
    constructor(options?: CompressionPluginOptions);
    initRuntimeAdapter(options: FetchHandlerOptions<T>): void;
}

interface RPCHandlerOptions<T extends Context> extends FetchHandlerOptions<T>, Omit<StandardRPCHandlerOptions<T>, 'plugins'> {
    /**
     * Enables or disables the StrictGetMethodPlugin.
     *
     * @default true
     */
    strictGetMethodPluginEnabled?: boolean;
}
/**
 * RPC Handler for Fetch Server
 *
 * @see {@link https://orpc.unnoq.com/docs/rpc-handler RPC Handler Docs}
 * @see {@link https://orpc.unnoq.com/docs/adapters/http HTTP Adapter Docs}
 */
declare class RPCHandler<T extends Context> extends FetchHandler<T> {
    constructor(router: Router<any, T>, options?: NoInfer<RPCHandlerOptions<T>>);
}

export { BodyLimitPlugin, CompositeFetchHandlerPlugin, CompressionPlugin, FetchHandler, RPCHandler };
export type { BodyLimitPluginOptions, CompressionPluginOptions, FetchHandleResult, FetchHandlerInterceptorOptions, FetchHandlerOptions, FetchHandlerPlugin, RPCHandlerOptions };
