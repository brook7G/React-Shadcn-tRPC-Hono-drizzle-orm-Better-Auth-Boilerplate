import { N as NestedClient, C as ClientLink, I as InferClientContext, a as ClientPromiseResult, b as ClientContext, F as FriendlyClientOptions, c as ClientOptions, d as Client, e as ClientRest } from './shared/client.BOYsZIRq.js';
export { f as HTTPMethod, H as HTTPPath } from './shared/client.BOYsZIRq.js';
import { MaybeOptionalOptions, ThrowableError, OnFinishState, Promisable, AsyncIteratorClass } from '@orpc/shared';
export { AsyncIteratorClass, EventPublisher, EventPublisherOptions, EventPublisherSubscribeIteratorOptions, Registry, ThrowableError, asyncIteratorToStream as eventIteratorToStream, onError, onFinish, onStart, onSuccess, streamToAsyncIteratorClass as streamToEventIterator } from '@orpc/shared';
export { ErrorEvent } from '@orpc/standard-server';

interface createORPCClientOptions {
    /**
     * Use as base path for all procedure, useful when you only want to call a subset of the procedure.
     */
    path?: readonly string[];
}
/**
 * Create a oRPC client-side client from a link.
 *
 * @see {@link https://orpc.unnoq.com/docs/client/client-side Client-side Client Docs}
 */
declare function createORPCClient<T extends NestedClient<any>>(link: ClientLink<InferClientContext<T>>, options?: createORPCClientOptions): T;

declare const COMMON_ORPC_ERROR_DEFS: {
    readonly BAD_REQUEST: {
        readonly status: 400;
        readonly message: "Bad Request";
    };
    readonly UNAUTHORIZED: {
        readonly status: 401;
        readonly message: "Unauthorized";
    };
    readonly FORBIDDEN: {
        readonly status: 403;
        readonly message: "Forbidden";
    };
    readonly NOT_FOUND: {
        readonly status: 404;
        readonly message: "Not Found";
    };
    readonly METHOD_NOT_SUPPORTED: {
        readonly status: 405;
        readonly message: "Method Not Supported";
    };
    readonly NOT_ACCEPTABLE: {
        readonly status: 406;
        readonly message: "Not Acceptable";
    };
    readonly TIMEOUT: {
        readonly status: 408;
        readonly message: "Request Timeout";
    };
    readonly CONFLICT: {
        readonly status: 409;
        readonly message: "Conflict";
    };
    readonly PRECONDITION_FAILED: {
        readonly status: 412;
        readonly message: "Precondition Failed";
    };
    readonly PAYLOAD_TOO_LARGE: {
        readonly status: 413;
        readonly message: "Payload Too Large";
    };
    readonly UNSUPPORTED_MEDIA_TYPE: {
        readonly status: 415;
        readonly message: "Unsupported Media Type";
    };
    readonly UNPROCESSABLE_CONTENT: {
        readonly status: 422;
        readonly message: "Unprocessable Content";
    };
    readonly TOO_MANY_REQUESTS: {
        readonly status: 429;
        readonly message: "Too Many Requests";
    };
    readonly CLIENT_CLOSED_REQUEST: {
        readonly status: 499;
        readonly message: "Client Closed Request";
    };
    readonly INTERNAL_SERVER_ERROR: {
        readonly status: 500;
        readonly message: "Internal Server Error";
    };
    readonly NOT_IMPLEMENTED: {
        readonly status: 501;
        readonly message: "Not Implemented";
    };
    readonly BAD_GATEWAY: {
        readonly status: 502;
        readonly message: "Bad Gateway";
    };
    readonly SERVICE_UNAVAILABLE: {
        readonly status: 503;
        readonly message: "Service Unavailable";
    };
    readonly GATEWAY_TIMEOUT: {
        readonly status: 504;
        readonly message: "Gateway Timeout";
    };
};
type CommonORPCErrorCode = keyof typeof COMMON_ORPC_ERROR_DEFS;
type ORPCErrorCode = CommonORPCErrorCode | (string & {});
declare function fallbackORPCErrorStatus(code: ORPCErrorCode, status: number | undefined): number;
declare function fallbackORPCErrorMessage(code: ORPCErrorCode, message: string | undefined): string;
type ORPCErrorOptions<TData> = ErrorOptions & {
    defined?: boolean;
    status?: number;
    message?: string;
} & (undefined extends TData ? {
    data?: TData;
} : {
    data: TData;
});
declare class ORPCError<TCode extends ORPCErrorCode, TData> extends Error {
    readonly defined: boolean;
    readonly code: TCode;
    readonly status: number;
    readonly data: TData;
    constructor(code: TCode, ...rest: MaybeOptionalOptions<ORPCErrorOptions<TData>>);
    toJSON(): ORPCErrorJSON<TCode, TData>;
    /**
     * Workaround for Next.js where different contexts use separate
     * dependency graphs, causing multiple ORPCError constructors existing and breaking
     * `instanceof` checks across contexts.
     *
     * This is particularly problematic with "Optimized SSR", where orpc-client
     * executes in one context but is invoked from another. When an error is thrown
     * in the execution context, `instanceof ORPCError` checks fail in the
     * invocation context due to separate class constructors.
     *
     * @todo Remove this and related code if Next.js resolves the multiple dependency graph issue.
     */
    static [Symbol.hasInstance](instance: unknown): boolean;
}
type ORPCErrorJSON<TCode extends string, TData> = Pick<ORPCError<TCode, TData>, 'defined' | 'code' | 'status' | 'message' | 'data'>;
declare function isDefinedError<T>(error: T): error is Extract<T, ORPCError<any, any>>;
declare function toORPCError(error: unknown): ORPCError<any, any>;
declare function isORPCErrorStatus(status: number): boolean;
declare function isORPCErrorJson(json: unknown): json is ORPCErrorJSON<ORPCErrorCode, unknown>;
declare function createORPCErrorFromJson<TCode extends ORPCErrorCode, TData>(json: ORPCErrorJSON<TCode, TData>, options?: ErrorOptions): ORPCError<TCode, TData>;

type SafeResult<TOutput, TError> = [error: null, data: TOutput, isDefined: false, isSuccess: true] & {
    error: null;
    data: TOutput;
    isDefined: false;
    isSuccess: true;
} | [error: Exclude<TError, ORPCError<any, any>>, data: undefined, isDefined: false, isSuccess: false] & {
    error: Exclude<TError, ORPCError<any, any>>;
    data: undefined;
    isDefined: false;
    isSuccess: false;
} | [error: Extract<TError, ORPCError<any, any>>, data: undefined, isDefined: true, isSuccess: false] & {
    error: Extract<TError, ORPCError<any, any>>;
    data: undefined;
    isDefined: true;
    isSuccess: false;
};
/**
 * Works like try/catch, but can infer error types.
 *
 * @info support both tuple `[error, data, isDefined, isSuccess]` and object `{ error, data, isDefined, isSuccess }` styles.
 * @see {@link https://orpc.unnoq.com/docs/client/error-handling Client Error Handling Docs}
 */
declare function safe<TOutput, TError = ThrowableError>(promise: ClientPromiseResult<TOutput, TError>): Promise<SafeResult<TOutput, TError>>;
declare function resolveFriendlyClientOptions<T extends ClientContext>(options: FriendlyClientOptions<T>): ClientOptions<T>;
interface ConsumeEventIteratorOptions<T, TReturn, TError> {
    /**
     * Called on each event
     */
    onEvent: (event: T) => void;
    /**
     * Called once error happens
     */
    onError?: (error: TError) => void;
    /**
     * Called once event iterator is done
     *
     * @info If iterator is canceled, `undefined` can be passed on success
     */
    onSuccess?: (value: TReturn | undefined) => void;
    /**
     * Called once after onError or onSuccess
     *
     * @info If iterator is canceled, `undefined` can be passed on success
     */
    onFinish?: (state: OnFinishState<TReturn | undefined, TError>) => void;
}
/**
 * Consumes an event iterator with lifecycle callbacks
 *
 * @warning If no `onError` or `onFinish` is provided, unhandled rejections will be thrown
 * @return unsubscribe callback
 */
declare function consumeEventIterator<T, TReturn, TError = ThrowableError>(iterator: AsyncIterator<T, TReturn> | ClientPromiseResult<AsyncIterator<T, TReturn>, TError>, options: ConsumeEventIteratorOptions<T, TReturn, TError>): () => Promise<void>;

type SafeClient<T extends NestedClient<any>> = T extends Client<infer UContext, infer UInput, infer UOutput, infer UError> ? (...rest: ClientRest<UContext, UInput>) => Promise<SafeResult<UOutput, UError>> : {
    [K in keyof T]: T[K] extends NestedClient<any> ? SafeClient<T[K]> : never;
};
/**
 * Create a safe client that automatically wraps all procedure calls with the `safe` util.
 *
 * @example
 * ```ts
 * const safeClient = createSafeClient(client)
 * const { error, data, isDefined } = await safeClient.doSomething({ id: '123' })
 * ```
 *
 * @see {@link https://orpc.unnoq.com/docs/client/error-handling#using-createsafeclient Safe Client Docs}
 */
declare function createSafeClient<T extends NestedClient<any>>(client: T): SafeClient<T>;

declare const ORPC_CLIENT_PACKAGE_NAME = "@orpc/client";
declare const ORPC_CLIENT_PACKAGE_VERSION = "1.9.2";

/**
 * DynamicLink provides a way to dynamically resolve and delegate calls to other ClientLinks
 * based on the request path, input, and context.
 *
 * @see {@link https://orpc.unnoq.com/docs/client/dynamic-link Dynamic Link Docs}
 */
declare class DynamicLink<TClientContext extends ClientContext> implements ClientLink<TClientContext> {
    private readonly linkResolver;
    constructor(linkResolver: (options: ClientOptions<TClientContext>, path: readonly string[], input: unknown) => Promisable<ClientLink<TClientContext>>);
    call(path: readonly string[], input: unknown, options: ClientOptions<TClientContext>): Promise<unknown>;
}

declare function mapEventIterator<TYield, TReturn, TNext, TMap = TYield | TReturn>(iterator: AsyncIterator<TYield, TReturn, TNext>, maps: {
    value: (value: NoInfer<TYield | TReturn>, done: boolean | undefined) => Promise<TMap>;
    error: (error: unknown) => Promise<unknown>;
}): AsyncIteratorClass<TMap, TMap, TNext>;

export { COMMON_ORPC_ERROR_DEFS, Client, ClientContext, ClientLink, ClientOptions, ClientPromiseResult, ClientRest, DynamicLink, FriendlyClientOptions, InferClientContext, NestedClient, ORPCError, ORPC_CLIENT_PACKAGE_NAME, ORPC_CLIENT_PACKAGE_VERSION, consumeEventIterator, createORPCClient, createORPCErrorFromJson, createSafeClient, fallbackORPCErrorMessage, fallbackORPCErrorStatus, isDefinedError, isORPCErrorJson, isORPCErrorStatus, mapEventIterator, resolveFriendlyClientOptions, safe, toORPCError };
export type { CommonORPCErrorCode, ConsumeEventIteratorOptions, ORPCErrorCode, ORPCErrorJSON, ORPCErrorOptions, SafeClient, SafeResult, createORPCClientOptions };
