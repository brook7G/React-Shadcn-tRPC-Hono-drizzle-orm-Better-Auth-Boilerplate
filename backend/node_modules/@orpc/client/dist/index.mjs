import { preventNativeAwait, isTypescriptObject } from '@orpc/shared';
export { AsyncIteratorClass, EventPublisher, asyncIteratorToStream as eventIteratorToStream, onError, onFinish, onStart, onSuccess, streamToAsyncIteratorClass as streamToEventIterator } from '@orpc/shared';
import { i as isDefinedError } from './shared/client.DVVKXLEa.mjs';
export { C as COMMON_ORPC_ERROR_DEFS, c as ORPCError, O as ORPC_CLIENT_PACKAGE_NAME, a as ORPC_CLIENT_PACKAGE_VERSION, g as createORPCErrorFromJson, b as fallbackORPCErrorMessage, f as fallbackORPCErrorStatus, e as isORPCErrorJson, d as isORPCErrorStatus, m as mapEventIterator, t as toORPCError } from './shared/client.DVVKXLEa.mjs';
export { ErrorEvent } from '@orpc/standard-server';

async function safe(promise) {
  try {
    const output = await promise;
    return Object.assign(
      [null, output, false, true],
      { error: null, data: output, isDefined: false, isSuccess: true }
    );
  } catch (e) {
    const error = e;
    if (isDefinedError(error)) {
      return Object.assign(
        [error, void 0, true, false],
        { error, data: void 0, isDefined: true, isSuccess: false }
      );
    }
    return Object.assign(
      [error, void 0, false, false],
      { error, data: void 0, isDefined: false, isSuccess: false }
    );
  }
}
function resolveFriendlyClientOptions(options) {
  return {
    ...options,
    context: options.context ?? {}
    // Context only optional if all fields are optional
  };
}
function consumeEventIterator(iterator, options) {
  void (async () => {
    let onFinishState;
    try {
      const resolvedIterator = await iterator;
      while (true) {
        const { done, value } = await resolvedIterator.next();
        if (done) {
          const realValue = value;
          onFinishState = [null, realValue, true];
          options.onSuccess?.(realValue);
          break;
        }
        options.onEvent(value);
      }
    } catch (error) {
      onFinishState = [error, void 0, false];
      if (!options.onError && !options.onFinish) {
        throw error;
      }
      options.onError?.(error);
    } finally {
      options.onFinish?.(onFinishState);
    }
  })();
  return async () => {
    await (await iterator)?.return?.();
  };
}

function createORPCClient(link, options = {}) {
  const path = options.path ?? [];
  const procedureClient = async (...[input, options2 = {}]) => {
    return await link.call(path, input, resolveFriendlyClientOptions(options2));
  };
  const recursive = new Proxy(procedureClient, {
    get(target, key) {
      if (typeof key !== "string") {
        return Reflect.get(target, key);
      }
      return createORPCClient(link, {
        ...options,
        path: [...path, key]
      });
    }
  });
  return preventNativeAwait(recursive);
}

function createSafeClient(client) {
  const proxy = new Proxy((...args) => safe(client(...args)), {
    get(_, prop, receiver) {
      const value = Reflect.get(client, prop, receiver);
      if (typeof prop !== "string") {
        return value;
      }
      if (!isTypescriptObject(value)) {
        return value;
      }
      return createSafeClient(value);
    }
  });
  return proxy;
}

class DynamicLink {
  constructor(linkResolver) {
    this.linkResolver = linkResolver;
  }
  async call(path, input, options) {
    const resolvedLink = await this.linkResolver(options, path, input);
    const output = await resolvedLink.call(path, input, options);
    return output;
  }
}

export { DynamicLink, consumeEventIterator, createORPCClient, createSafeClient, isDefinedError, resolveFriendlyClientOptions, safe };
