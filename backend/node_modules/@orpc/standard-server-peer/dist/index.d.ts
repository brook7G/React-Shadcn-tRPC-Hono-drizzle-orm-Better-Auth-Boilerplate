import { Promisable, AsyncIdQueueCloseOptions as AsyncIdQueueCloseOptions$1, SetSpanErrorOptions, AsyncIteratorClassCleanupFn, AsyncIteratorClass } from '@orpc/shared';
import { StandardRequest, StandardResponse, EventMeta } from '@orpc/standard-server';

type EncodedMessage = string | ArrayBufferLike | Uint8Array;
interface EncodedMessageSendFn {
    (message: EncodedMessage): Promisable<void>;
}

interface ClientPeerCloseOptions extends AsyncIdQueueCloseOptions$1 {
    /**
     * Should abort or not?
     *
     * @default true
     */
    abort?: boolean;
}
declare class ClientPeer {
    private readonly idGenerator;
    /**
     * Queue of responses sent from server, awaiting consumption
     */
    private readonly responseQueue;
    /**
     * Queue of event iterator messages sent from server, awaiting consumption
     */
    private readonly serverEventIteratorQueue;
    /**
     * Controllers used to signal that the client should stop sending event iterator messages
     */
    private readonly serverControllers;
    /**
     * Cleanup functions invoked when the request/response is closed
     */
    private readonly cleanupFns;
    private readonly send;
    constructor(send: EncodedMessageSendFn);
    get length(): number;
    open(id: string): AbortController;
    request(request: StandardRequest): Promise<StandardResponse>;
    message(raw: EncodedMessage): Promise<void>;
    close(options?: AsyncIdQueueCloseOptions$1): void;
}

declare enum MessageType {
    REQUEST = 1,
    RESPONSE = 2,
    EVENT_ITERATOR = 3,
    ABORT_SIGNAL = 4
}
type EventIteratorEvent = 'message' | 'error' | 'done';
interface EventIteratorPayload {
    event: EventIteratorEvent;
    data: unknown;
    meta?: EventMeta;
}
interface RequestMessageMap {
    [MessageType.REQUEST]: Omit<StandardRequest, 'signal'>;
    [MessageType.EVENT_ITERATOR]: EventIteratorPayload;
    [MessageType.ABORT_SIGNAL]: void;
}
interface ResponseMessageMap {
    [MessageType.RESPONSE]: StandardResponse;
    [MessageType.EVENT_ITERATOR]: EventIteratorPayload;
    [MessageType.ABORT_SIGNAL]: void;
}
type DecodedMessageUnion<TMap extends RequestMessageMap | ResponseMessageMap> = {
    [K in keyof TMap]: [id: string, type: K, payload: TMap[K]];
}[keyof TMap];
type DecodedRequestMessage = DecodedMessageUnion<RequestMessageMap>;
type DecodedResponseMessage = DecodedMessageUnion<ResponseMessageMap>;
declare function encodeRequestMessage<T extends keyof RequestMessageMap>(id: string, type: T, payload: RequestMessageMap[T]): Promise<EncodedMessage>;
declare function decodeRequestMessage(raw: EncodedMessage): Promise<DecodedRequestMessage>;
declare function encodeResponseMessage<T extends keyof ResponseMessageMap>(id: string, type: T, payload: ResponseMessageMap[T]): Promise<EncodedMessage>;
declare function decodeResponseMessage(raw: EncodedMessage): Promise<DecodedResponseMessage>;

interface AsyncIdQueueCloseOptions {
    id?: string;
    reason?: unknown;
}
declare class AsyncIdQueue<T> {
    private readonly openIds;
    private readonly queues;
    private readonly waiters;
    get length(): number;
    get waiterIds(): string[];
    hasBufferedItems(id: string): boolean;
    open(id: string): void;
    isOpen(id: string): boolean;
    push(id: string, item: T): void;
    pull(id: string): Promise<T>;
    close({ id, reason }?: AsyncIdQueueCloseOptions): void;
    assertOpen(id: string): void;
}

interface ToEventIteratorOptions extends SetSpanErrorOptions {
}
declare function toEventIterator(queue: AsyncIdQueue<EventIteratorPayload>, id: string, cleanup: AsyncIteratorClassCleanupFn, options?: ToEventIteratorOptions): AsyncIteratorClass<unknown>;
declare function resolveEventIterator(iterator: AsyncIterator<any>, callback: (payload: EventIteratorPayload) => Promise<'next' | 'abort'>): Promise<void>;

interface ServerPeerHandleRequestFn {
    (request: StandardRequest): Promise<StandardResponse>;
}
interface ServerPeerCloseOptions extends AsyncIdQueueCloseOptions$1 {
    /**
     * Should abort or not?
     *
     * @default true
     */
    abort?: boolean;
}
declare class ServerPeer {
    /**
     * Queue of event iterator messages sent from client, awaiting consumption
     */
    private readonly clientEventIteratorQueue;
    /**
     * Map of active client request controllers, should be synced to request signal
     */
    private readonly clientControllers;
    private readonly send;
    constructor(send: EncodedMessageSendFn);
    get length(): number;
    open(id: string): AbortController;
    /**
     * @todo This method will return Promise<void> in the next major version.
     */
    message(raw: EncodedMessage, handleRequest?: ServerPeerHandleRequestFn): Promise<[id: string, StandardRequest | undefined]>;
    /**
     * @deprecated Please pass the `handleRequest` (second arg) function to the `message` method instead.
     */
    response(id: string, response: StandardResponse): Promise<void>;
    close({ abort, ...options }?: ServerPeerCloseOptions): void;
}

export { ClientPeer, MessageType, ServerPeer, decodeRequestMessage, decodeResponseMessage, encodeRequestMessage, encodeResponseMessage, resolveEventIterator, toEventIterator };
export type { ClientPeerCloseOptions, DecodedRequestMessage, DecodedResponseMessage, EncodedMessage, EncodedMessageSendFn, EventIteratorEvent, EventIteratorPayload, RequestMessageMap, ResponseMessageMap, ServerPeerCloseOptions, ServerPeerHandleRequestFn, ToEventIteratorOptions };
