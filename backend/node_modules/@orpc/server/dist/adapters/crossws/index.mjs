import { resolveMaybeOptionalOptions } from '@orpc/shared';
import { ServerPeer } from '@orpc/standard-server-peer';
import { c as createServerPeerHandleRequestFn } from '../../shared/server.UVMTOWrk.mjs';
import '@orpc/client';
import '@orpc/standard-server';
import '@orpc/contract';
import { b as StandardRPCHandler } from '../../shared/server.Bxx6tqNe.mjs';
import '@orpc/client/standard';
import '../../shared/server.DZ5BIITo.mjs';
import '../../shared/server.Ds4HPpvH.mjs';

class experimental_CrosswsHandler {
  constructor(standardHandler) {
    this.standardHandler = standardHandler;
  }
  peers = /* @__PURE__ */ new WeakMap();
  async message(ws, message, ...rest) {
    let peer = this.peers.get(ws);
    if (!peer) {
      this.peers.set(ws, peer = new ServerPeer((message2) => {
        ws.send(message2);
      }));
    }
    const encodedMessage = typeof message.rawData === "string" ? message.rawData : message.uint8Array();
    await peer.message(
      encodedMessage,
      createServerPeerHandleRequestFn(this.standardHandler, resolveMaybeOptionalOptions(rest))
    );
  }
  close(ws) {
    const server = this.peers.get(ws);
    if (server) {
      server.close();
      this.peers.delete(ws);
    }
  }
}

class experimental_RPCHandler extends experimental_CrosswsHandler {
  constructor(router, options = {}) {
    super(new StandardRPCHandler(router, options));
  }
}

export { experimental_CrosswsHandler, experimental_RPCHandler };
