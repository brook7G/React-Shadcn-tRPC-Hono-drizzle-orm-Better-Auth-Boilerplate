import { AsyncIteratorClass } from '@orpc/shared';
import { S as StandardHeaders, a as StandardLazyResponse } from './shared/standard-server.BD8Sg1A5.mjs';
export { b as StandardBody, d as StandardLazyRequest, c as StandardRequest, e as StandardResponse } from './shared/standard-server.BD8Sg1A5.mjs';

interface EventMessage {
    event: string | undefined;
    id: string | undefined;
    data: string | undefined;
    /**
     * The number of milliseconds to wait before retrying the event iterator if error occurs.
     */
    retry: number | undefined;
    comments: string[];
}

declare function decodeEventMessage(encoded: string): EventMessage;
interface EventDecoderOptions {
    onEvent?: (event: EventMessage) => void;
}
declare class EventDecoder {
    private options;
    private incomplete;
    constructor(options?: EventDecoderOptions);
    feed(chunk: string): void;
    end(): void;
}
declare class EventDecoderStream extends TransformStream<string, EventMessage> {
    constructor();
}

declare function assertEventId(id: string): void;
declare function assertEventName(event: string): void;
declare function assertEventRetry(retry: number): void;
declare function assertEventComment(comment: string): void;
declare function encodeEventData(data: string | undefined): string;
declare function encodeEventComments(comments: string[] | undefined): string;
declare function encodeEventMessage(message: Partial<EventMessage>): string;

declare class EventEncoderError extends TypeError {
}
declare class EventDecoderError extends TypeError {
}
interface ErrorEventOptions extends ErrorOptions {
    message?: string;
    data?: unknown;
}
declare class ErrorEvent extends Error {
    data: unknown;
    constructor(options?: ErrorEventOptions);
}

type EventMeta = Partial<Pick<EventMessage, 'retry' | 'id' | 'comments'>>;
declare function withEventMeta<T extends object>(container: T, meta: EventMeta): T;
declare function getEventMeta(container: unknown): EventMeta | undefined;

interface HibernationEventIteratorCallback {
    (id: string): void;
}
declare class HibernationEventIterator<T, TReturn = unknown, TNext = unknown> extends AsyncIteratorClass<T, TReturn, TNext> {
    /**
     * this property is not transferred to the client, so it should be optional for type safety
     */
    readonly hibernationCallback?: HibernationEventIteratorCallback;
    constructor(hibernationCallback: HibernationEventIteratorCallback);
}

declare function generateContentDisposition(filename: string): string;
declare function getFilenameFromContentDisposition(contentDisposition: string): string | undefined;
declare function mergeStandardHeaders(a: StandardHeaders, b: StandardHeaders): StandardHeaders;
declare function flattenHeader(header: string | readonly string[] | undefined): string | undefined;
declare function replicateStandardLazyResponse(response: StandardLazyResponse, count: number): StandardLazyResponse[];
declare function isEventIteratorHeaders(headers: StandardHeaders): boolean;

export { ErrorEvent, EventDecoder, EventDecoderError, EventDecoderStream, EventEncoderError, HibernationEventIterator, StandardHeaders, StandardLazyResponse, assertEventComment, assertEventId, assertEventName, assertEventRetry, decodeEventMessage, encodeEventComments, encodeEventData, encodeEventMessage, flattenHeader, generateContentDisposition, getEventMeta, getFilenameFromContentDisposition, isEventIteratorHeaders, mergeStandardHeaders, replicateStandardLazyResponse, withEventMeta };
export type { ErrorEventOptions, EventDecoderOptions, EventMessage, EventMeta, HibernationEventIteratorCallback };
