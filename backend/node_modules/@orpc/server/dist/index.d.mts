import { ORPCErrorJSON, ORPCError, Client, ClientContext, HTTPPath, HTTPMethod, ClientOptions, ClientPromiseResult } from '@orpc/client';
export { ClientContext, HTTPMethod, HTTPPath, ORPCError, isDefinedError, safe } from '@orpc/client';
import { AnySchema, ErrorMap, InferSchemaInput, InferSchemaOutput, ErrorFromErrorMap, Meta, MergedErrorMap, Route, Schema, ContractRouter, ContractProcedureDef, AnyContractRouter, ContractProcedure, InferContractRouterErrorMap, InferContractRouterMeta, AnyContractProcedure } from '@orpc/contract';
export { ContractProcedure, ContractProcedureDef, ContractRouter, ErrorMap, ErrorMapItem, InferSchemaInput, InferSchemaOutput, InputStructure, MergedErrorMap, Meta, OutputStructure, Route, Schema, ValidationError, eventIterator, type, validateORPCError } from '@orpc/contract';
import { ThrowableError, IntersectPick, MaybeOptionalOptions } from '@orpc/shared';
export { AsyncIteratorClass, EventPublisher, EventPublisherOptions, EventPublisherSubscribeIteratorOptions, IntersectPick, Registry, ThrowableError, asyncIteratorToStream as eventIteratorToStream, onError, onFinish, onStart, onSuccess, streamToAsyncIteratorClass as streamToEventIterator } from '@orpc/shared';
import { C as Context, P as Procedure, e as Middleware, O as ORPCErrorConstructorMap, M as MergedInitialContext, f as MergedCurrentContext, g as MapInputMiddleware, h as CreateProcedureClientOptions, i as ProcedureClient, j as ProcedureHandler, R as Router, c as Lazy, a as AnyMiddleware, b as AnyRouter, A as AnyProcedure, L as Lazyable, I as InferRouterInitialContext } from './shared/server.B4BGqy3Y.mjs';
export { H as InferRouterCurrentContexts, G as InferRouterInitialContexts, J as InferRouterInputs, K as InferRouterOutputs, o as LAZY_SYMBOL, p as LazyMeta, w as MiddlewareNextFn, v as MiddlewareNextFnOptions, y as MiddlewareOptions, x as MiddlewareOutputFn, t as MiddlewareResult, l as ORPCErrorConstructorMapItem, k as ORPCErrorConstructorMapItemOptions, d as ProcedureClientInterceptorOptions, D as ProcedureDef, B as ProcedureHandlerOptions, n as createORPCErrorConstructorMap, F as createProcedureClient, s as getLazyMeta, r as isLazy, E as isProcedure, q as lazy, m as mergeCurrentContext, z as middlewareOutputFn, u as unlazy } from './shared/server.B4BGqy3Y.mjs';
import { E as EnhanceRouterOptions, a as EnhancedRouter } from './shared/server.DzV1hr3z.mjs';
export { A as AccessibleLazyRouter, C as ContractProcedureCallbackOptions, L as LazyTraverseContractProceduresOptions, T as TraverseContractProcedureCallbackOptions, b as TraverseContractProceduresOptions, U as UnlaziedRouter, c as createAccessibleLazyRouter, e as enhanceRouter, g as getRouter, r as resolveContractProcedures, t as traverseContractProcedures, u as unlazyRouter } from './shared/server.DzV1hr3z.mjs';
export { getEventMeta, withEventMeta } from '@orpc/standard-server';

type ActionableError<T> = T extends ORPCError<infer U, infer V> ? ORPCErrorJSON<U, V> & {
    defined: true;
} : ORPCErrorJSON<string, unknown> & {
    defined: false;
};
type UnactionableError<T> = T extends {
    defined: true;
} & ORPCErrorJSON<infer U, infer V> ? ORPCError<U, V> : ThrowableError;
type ActionableClientRest<TInput> = [input: TInput] | (undefined extends TInput ? [input?: TInput] : [input: TInput]);
type ActionableClientResult<TOutput, TError extends ORPCErrorJSON<any, any>> = [error: null, data: TOutput] | [error: TError, data: undefined];
interface ActionableClient<TInput, TOutput, TError extends ORPCErrorJSON<any, any>> {
    (...rest: ActionableClientRest<TInput>): Promise<ActionableClientResult<TOutput, TError>>;
}
type ProcedureActionableClient<TInputSchema extends AnySchema, TOutputSchema extends AnySchema, TErrorMap extends ErrorMap> = ActionableClient<InferSchemaInput<TInputSchema>, InferSchemaOutput<TOutputSchema>, ActionableError<ErrorFromErrorMap<TErrorMap>>>;
declare function createActionableClient<TInput, TOutput, TError>(client: Client<Record<never, never>, TInput, TOutput, TError>): ActionableClient<TInput, TOutput, ActionableError<TError>>;

declare class DecoratedProcedure<TInitialContext extends Context, TCurrentContext extends Context, TInputSchema extends AnySchema, TOutputSchema extends AnySchema, TErrorMap extends ErrorMap, TMeta extends Meta> extends Procedure<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta> {
    /**
     * Adds type-safe custom errors.
     * The provided errors are spared-merged with any existing errors.
     *
     * @see {@link https://orpc.unnoq.com/docs/error-handling#type%E2%80%90safe-error-handling Type-Safe Error Handling Docs}
     */
    errors<U extends ErrorMap>(errors: U): DecoratedProcedure<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, MergedErrorMap<TErrorMap, U>, TMeta>;
    /**
     * Sets or updates the metadata.
     * The provided metadata is spared-merged with any existing metadata.
     *
     * @see {@link https://orpc.unnoq.com/docs/metadata Metadata Docs}
     */
    meta(meta: TMeta): DecoratedProcedure<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Sets or updates the route definition.
     * The provided route is spared-merged with any existing route.
     * This option is typically relevant when integrating with OpenAPI.
     *
     * @see {@link https://orpc.unnoq.com/docs/openapi/routing OpenAPI Routing Docs}
     * @see {@link https://orpc.unnoq.com/docs/openapi/input-output-structure OpenAPI Input/Output Structure Docs}
     */
    route(route: Route): DecoratedProcedure<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Uses a middleware to modify the context or improve the pipeline.
     *
     * @info Supports both normal middleware and inline middleware implementations.
     * @info Pass second argument to map the input.
     * @note The current context must be satisfy middleware dependent-context
     * @see {@link https://orpc.unnoq.com/docs/middleware Middleware Docs}
     */
    use<UOutContext extends IntersectPick<TCurrentContext, UOutContext>, UInContext extends Context = TCurrentContext>(middleware: Middleware<UInContext | TCurrentContext, UOutContext, InferSchemaOutput<TInputSchema>, InferSchemaInput<TOutputSchema>, ORPCErrorConstructorMap<TErrorMap>, TMeta>): DecoratedProcedure<MergedInitialContext<TInitialContext, UInContext, TCurrentContext>, MergedCurrentContext<TCurrentContext, UOutContext>, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Uses a middleware to modify the context or improve the pipeline.
     *
     * @info Supports both normal middleware and inline middleware implementations.
     * @info Pass second argument to map the input.
     * @note The current context must be satisfy middleware dependent-context
     * @see {@link https://orpc.unnoq.com/docs/middleware Middleware Docs}
     */
    use<UOutContext extends IntersectPick<TCurrentContext, UOutContext>, UInput, UInContext extends Context = TCurrentContext>(middleware: Middleware<UInContext | TCurrentContext, UOutContext, UInput, InferSchemaInput<TOutputSchema>, ORPCErrorConstructorMap<TErrorMap>, TMeta>, mapInput: MapInputMiddleware<InferSchemaOutput<TInputSchema>, UInput>): DecoratedProcedure<MergedInitialContext<TInitialContext, UInContext, TCurrentContext>, MergedCurrentContext<TCurrentContext, UOutContext>, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Make this procedure callable (works like a function while still being a procedure).
     *
     * @see {@link https://orpc.unnoq.com/docs/client/server-side Server-side Client Docs}
     */
    callable<TClientContext extends ClientContext>(...rest: MaybeOptionalOptions<CreateProcedureClientOptions<TInitialContext, TOutputSchema, TErrorMap, TMeta, TClientContext>>): DecoratedProcedure<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta> & ProcedureClient<TClientContext, TInputSchema, TOutputSchema, TErrorMap>;
    /**
     * Make this procedure compatible with server action.
     *
     * @see {@link https://orpc.unnoq.com/docs/server-action Server Action Docs}
     */
    actionable(...rest: MaybeOptionalOptions<CreateProcedureClientOptions<TInitialContext, TOutputSchema, TErrorMap, TMeta, Record<never, never>>>): DecoratedProcedure<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta> & ProcedureActionableClient<TInputSchema, TOutputSchema, TErrorMap>;
}

interface BuilderWithMiddlewares<TInitialContext extends Context, TCurrentContext extends Context, TInputSchema extends AnySchema, TOutputSchema extends AnySchema, TErrorMap extends ErrorMap, TMeta extends Meta> {
    /**
     * This property holds the defined options.
     */
    '~orpc': BuilderDef<TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Adds type-safe custom errors.
     * The provided errors are spared-merged with any existing errors.
     *
     * @see {@link https://orpc.unnoq.com/docs/error-handling#type%E2%80%90safe-error-handling Type-Safe Error Handling Docs}
     */
    'errors'<U extends ErrorMap>(errors: U): BuilderWithMiddlewares<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, MergedErrorMap<TErrorMap, U>, TMeta>;
    /**
     * Uses a middleware to modify the context or improve the pipeline.
     *
     * @info Supports both normal middleware and inline middleware implementations.
     * @note The current context must be satisfy middleware dependent-context
     * @see {@link https://orpc.unnoq.com/docs/middleware Middleware Docs}
     */
    'use'<UOutContext extends IntersectPick<TCurrentContext, UOutContext>, UInContext extends Context = TCurrentContext>(middleware: Middleware<UInContext | TCurrentContext, UOutContext, unknown, unknown, ORPCErrorConstructorMap<TErrorMap>, TMeta>): BuilderWithMiddlewares<MergedInitialContext<TInitialContext, UInContext, TCurrentContext>, MergedCurrentContext<TCurrentContext, UOutContext>, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Sets or updates the metadata.
     * The provided metadata is spared-merged with any existing metadata.
     *
     * @see {@link https://orpc.unnoq.com/docs/metadata Metadata Docs}
     */
    'meta'(meta: TMeta): BuilderWithMiddlewares<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Sets or updates the route definition.
     * The provided route is spared-merged with any existing route.
     * This option is typically relevant when integrating with OpenAPI.
     *
     * @see {@link https://orpc.unnoq.com/docs/openapi/routing OpenAPI Routing Docs}
     * @see {@link https://orpc.unnoq.com/docs/openapi/input-output-structure OpenAPI Input/Output Structure Docs}
     */
    'route'(route: Route): ProcedureBuilder<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Defines the input validation schema.
     *
     * @see {@link https://orpc.unnoq.com/docs/procedure#input-output-validation Input Validation Docs}
     */
    'input'<USchema extends AnySchema>(schema: USchema): ProcedureBuilderWithInput<TInitialContext, TCurrentContext, USchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Defines the output validation schema.
     *
     * @see {@link https://orpc.unnoq.com/docs/procedure#input-output-validation Output Validation Docs}
     */
    'output'<USchema extends AnySchema>(schema: USchema): ProcedureBuilderWithOutput<TInitialContext, TCurrentContext, TInputSchema, USchema, TErrorMap, TMeta>;
    /**
     * Defines the handler of the procedure.
     *
     * @see {@link https://orpc.unnoq.com/docs/procedure Procedure Docs}
     */
    'handler'<UFuncOutput>(handler: ProcedureHandler<TCurrentContext, unknown, UFuncOutput, TErrorMap, TMeta>): DecoratedProcedure<TInitialContext, TCurrentContext, TInputSchema, Schema<UFuncOutput, UFuncOutput>, TErrorMap, TMeta>;
    /**
     * Prefixes all procedures in the router.
     * The provided prefix is post-appended to any existing router prefix.
     *
     * @note This option does not affect procedures that do not define a path in their route definition.
     *
     * @see {@link https://orpc.unnoq.com/docs/openapi/routing#route-prefixes OpenAPI Route Prefixes Docs}
     */
    'prefix'(prefix: HTTPPath): RouterBuilder<TInitialContext, TCurrentContext, TErrorMap, TMeta>;
    /**
     * Adds tags to all procedures in the router.
     * This helpful when you want to group procedures together in the OpenAPI specification.
     *
     * @see {@link https://orpc.unnoq.com/docs/openapi/openapi-specification#operation-metadata OpenAPI Operation Metadata Docs}
     */
    'tag'(...tags: string[]): RouterBuilder<TInitialContext, TCurrentContext, TErrorMap, TMeta>;
    /**
     * Applies all of the previously defined options to the specified router.
     *
     * @see {@link https://orpc.unnoq.com/docs/router#extending-router Extending Router Docs}
     */
    'router'<U extends Router<ContractRouter<TMeta>, TCurrentContext>>(router: U): EnhancedRouter<U, TInitialContext, TCurrentContext, TErrorMap>;
    /**
     * Create a lazy router
     * And applies all of the previously defined options to the specified router.
     *
     * @see {@link https://orpc.unnoq.com/docs/router#extending-router Extending Router Docs}
     */
    'lazy'<U extends Router<ContractRouter<TMeta>, TCurrentContext>>(loader: () => Promise<{
        default: U;
    }>): EnhancedRouter<Lazy<U>, TInitialContext, TCurrentContext, TErrorMap>;
}
interface ProcedureBuilder<TInitialContext extends Context, TCurrentContext extends Context, TInputSchema extends AnySchema, TOutputSchema extends AnySchema, TErrorMap extends ErrorMap, TMeta extends Meta> {
    /**
     * This property holds the defined options.
     */
    '~orpc': BuilderDef<TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Adds type-safe custom errors.
     * The provided errors are spared-merged with any existing errors.
     *
     * @see {@link https://orpc.unnoq.com/docs/error-handling#type%E2%80%90safe-error-handling Type-Safe Error Handling Docs}
     */
    'errors'<U extends ErrorMap>(errors: U): ProcedureBuilder<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, MergedErrorMap<TErrorMap, U>, TMeta>;
    /**
     * Uses a middleware to modify the context or improve the pipeline.
     *
     * @info Supports both normal middleware and inline middleware implementations.
     * @note The current context must be satisfy middleware dependent-context
     * @see {@link https://orpc.unnoq.com/docs/middleware Middleware Docs}
     */
    'use'<UOutContext extends IntersectPick<TCurrentContext, UOutContext>, UInContext extends Context = TCurrentContext>(middleware: Middleware<UInContext | TCurrentContext, UOutContext, unknown, unknown, ORPCErrorConstructorMap<TErrorMap>, TMeta>): ProcedureBuilder<MergedInitialContext<TInitialContext, UInContext, TCurrentContext>, MergedCurrentContext<TCurrentContext, UOutContext>, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Sets or updates the metadata.
     * The provided metadata is spared-merged with any existing metadata.
     *
     * @see {@link https://orpc.unnoq.com/docs/metadata Metadata Docs}
     */
    'meta'(meta: TMeta): ProcedureBuilder<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Sets or updates the route definition.
     * The provided route is spared-merged with any existing route.
     * This option is typically relevant when integrating with OpenAPI.
     *
     * @see {@link https://orpc.unnoq.com/docs/openapi/routing OpenAPI Routing Docs}
     * @see {@link https://orpc.unnoq.com/docs/openapi/input-output-structure OpenAPI Input/Output Structure Docs}
     */
    'route'(route: Route): ProcedureBuilder<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Defines the input validation schema.
     *
     * @see {@link https://orpc.unnoq.com/docs/procedure#input-output-validation Input Validation Docs}
     */
    'input'<USchema extends AnySchema>(schema: USchema): ProcedureBuilderWithInput<TInitialContext, TCurrentContext, USchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Defines the output validation schema.
     *
     * @see {@link https://orpc.unnoq.com/docs/procedure#input-output-validation Output Validation Docs}
     */
    'output'<USchema extends AnySchema>(schema: USchema): ProcedureBuilderWithOutput<TInitialContext, TCurrentContext, TInputSchema, USchema, TErrorMap, TMeta>;
    /**
     * Defines the handler of the procedure.
     *
     * @see {@link https://orpc.unnoq.com/docs/procedure Procedure Docs}
     */
    'handler'<UFuncOutput>(handler: ProcedureHandler<TCurrentContext, unknown, UFuncOutput, TErrorMap, TMeta>): DecoratedProcedure<TInitialContext, TCurrentContext, TInputSchema, Schema<UFuncOutput, UFuncOutput>, TErrorMap, TMeta>;
}
interface ProcedureBuilderWithInput<TInitialContext extends Context, TCurrentContext extends Context, TInputSchema extends AnySchema, TOutputSchema extends AnySchema, TErrorMap extends ErrorMap, TMeta extends Meta> {
    /**
     * This property holds the defined options.
     */
    '~orpc': BuilderDef<TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Adds type-safe custom errors.
     * The provided errors are spared-merged with any existing errors.
     *
     * @see {@link https://orpc.unnoq.com/docs/error-handling#type%E2%80%90safe-error-handling Type-Safe Error Handling Docs}
     */
    'errors'<U extends ErrorMap>(errors: U): ProcedureBuilderWithInput<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, MergedErrorMap<TErrorMap, U>, TMeta>;
    /**
     * Uses a middleware to modify the context or improve the pipeline.
     *
     * @info Supports both normal middleware and inline middleware implementations.
     * @info Pass second argument to map the input.
     * @note The current context must be satisfy middleware dependent-context
     * @see {@link https://orpc.unnoq.com/docs/middleware Middleware Docs}
     */
    'use'<UOutContext extends IntersectPick<TCurrentContext, UOutContext>, UInContext extends Context = TCurrentContext>(middleware: Middleware<UInContext | TCurrentContext, UOutContext, InferSchemaOutput<TInputSchema>, unknown, ORPCErrorConstructorMap<TErrorMap>, TMeta>): ProcedureBuilderWithInput<MergedInitialContext<TInitialContext, UInContext, TCurrentContext>, MergedCurrentContext<TCurrentContext, UOutContext>, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Uses a middleware to modify the context or improve the pipeline.
     *
     * @info Supports both normal middleware and inline middleware implementations.
     * @info Pass second argument to map the input.
     * @note The current context must be satisfy middleware dependent-context
     * @see {@link https://orpc.unnoq.com/docs/middleware Middleware Docs}
     */
    'use'<UOutContext extends IntersectPick<TCurrentContext, UOutContext>, UInput, UInContext extends Context = TCurrentContext>(middleware: Middleware<UInContext | TCurrentContext, UOutContext, UInput, unknown, ORPCErrorConstructorMap<TErrorMap>, TMeta>, mapInput: MapInputMiddleware<InferSchemaOutput<TInputSchema>, UInput>): ProcedureBuilderWithInput<MergedInitialContext<TInitialContext, UInContext, TCurrentContext>, MergedCurrentContext<TCurrentContext, UOutContext>, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Sets or updates the metadata.
     * The provided metadata is spared-merged with any existing metadata.
     *
     * @see {@link https://orpc.unnoq.com/docs/metadata Metadata Docs}
     */
    'meta'(meta: TMeta): ProcedureBuilderWithInput<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Sets or updates the route definition.
     * The provided route is spared-merged with any existing route.
     * This option is typically relevant when integrating with OpenAPI.
     *
     * @see {@link https://orpc.unnoq.com/docs/openapi/routing OpenAPI Routing Docs}
     * @see {@link https://orpc.unnoq.com/docs/openapi/input-output-structure OpenAPI Input/Output Structure Docs}
     */
    'route'(route: Route): ProcedureBuilderWithInput<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Defines the output validation schema.
     *
     * @see {@link https://orpc.unnoq.com/docs/procedure#input-output-validation Output Validation Docs}
     */
    'output'<USchema extends AnySchema>(schema: USchema): ProcedureBuilderWithInputOutput<TInitialContext, TCurrentContext, TInputSchema, USchema, TErrorMap, TMeta>;
    /**
     * Defines the handler of the procedure.
     *
     * @see {@link https://orpc.unnoq.com/docs/procedure Procedure Docs}
     */
    'handler'<UFuncOutput>(handler: ProcedureHandler<TCurrentContext, InferSchemaOutput<TInputSchema>, UFuncOutput, TErrorMap, TMeta>): DecoratedProcedure<TInitialContext, TCurrentContext, TInputSchema, Schema<UFuncOutput, UFuncOutput>, TErrorMap, TMeta>;
}
interface ProcedureBuilderWithOutput<TInitialContext extends Context, TCurrentContext extends Context, TInputSchema extends AnySchema, TOutputSchema extends AnySchema, TErrorMap extends ErrorMap, TMeta extends Meta> {
    /**
     * This property holds the defined options.
     */
    '~orpc': BuilderDef<TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Adds type-safe custom errors.
     * The provided errors are spared-merged with any existing errors.
     *
     * @see {@link https://orpc.unnoq.com/docs/error-handling#type%E2%80%90safe-error-handling Type-Safe Error Handling Docs}
     */
    'errors'<U extends ErrorMap>(errors: U): ProcedureBuilderWithOutput<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, MergedErrorMap<TErrorMap, U>, TMeta>;
    /**
     * Uses a middleware to modify the context or improve the pipeline.
     *
     * @info Supports both normal middleware and inline middleware implementations.
     * @note The current context must be satisfy middleware dependent-context
     * @see {@link https://orpc.unnoq.com/docs/middleware Middleware Docs}
     */
    'use'<UOutContext extends IntersectPick<TCurrentContext, UOutContext>, UInContext extends Context = TCurrentContext>(middleware: Middleware<UInContext | TCurrentContext, UOutContext, unknown, InferSchemaInput<TOutputSchema>, ORPCErrorConstructorMap<TErrorMap>, TMeta>): ProcedureBuilderWithOutput<MergedInitialContext<TInitialContext, UInContext, TCurrentContext>, MergedCurrentContext<TCurrentContext, UOutContext>, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Sets or updates the metadata.
     * The provided metadata is spared-merged with any existing metadata.
     *
     * @see {@link https://orpc.unnoq.com/docs/metadata Metadata Docs}
     */
    'meta'(meta: TMeta): ProcedureBuilderWithOutput<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Sets or updates the route definition.
     * The provided route is spared-merged with any existing route.
     * This option is typically relevant when integrating with OpenAPI.
     *
     * @see {@link https://orpc.unnoq.com/docs/openapi/routing OpenAPI Routing Docs}
     * @see {@link https://orpc.unnoq.com/docs/openapi/input-output-structure OpenAPI Input/Output Structure Docs}
     */
    'route'(route: Route): ProcedureBuilderWithOutput<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Defines the input validation schema.
     *
     * @see {@link https://orpc.unnoq.com/docs/procedure#input-output-validation Input Validation Docs}
     */
    'input'<USchema extends AnySchema>(schema: USchema): ProcedureBuilderWithInputOutput<TInitialContext, TCurrentContext, USchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Defines the handler of the procedure.
     *
     * @see {@link https://orpc.unnoq.com/docs/procedure Procedure Docs}
     */
    'handler'(handler: ProcedureHandler<TCurrentContext, unknown, InferSchemaInput<TOutputSchema>, TErrorMap, TMeta>): DecoratedProcedure<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
}
interface ProcedureBuilderWithInputOutput<TInitialContext extends Context, TCurrentContext extends Context, TInputSchema extends AnySchema, TOutputSchema extends AnySchema, TErrorMap extends ErrorMap, TMeta extends Meta> {
    /**
     * This property holds the defined options.
     */
    '~orpc': BuilderDef<TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Adds type-safe custom errors.
     * The provided errors are spared-merged with any existing errors.
     *
     * @see {@link https://orpc.unnoq.com/docs/error-handling#type%E2%80%90safe-error-handling Type-Safe Error Handling Docs}
     */
    'errors'<U extends ErrorMap>(errors: U): ProcedureBuilderWithInputOutput<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, MergedErrorMap<TErrorMap, U>, TMeta>;
    /**
     * Uses a middleware to modify the context or improve the pipeline.
     *
     * @info Supports both normal middleware and inline middleware implementations.
     * @info Pass second argument to map the input.
     * @note The current context must be satisfy middleware dependent-context
     * @see {@link https://orpc.unnoq.com/docs/middleware Middleware Docs}
     */
    'use'<UOutContext extends IntersectPick<TCurrentContext, UOutContext>, UInContext extends Context = TCurrentContext>(middleware: Middleware<UInContext | TCurrentContext, UOutContext, InferSchemaOutput<TInputSchema>, InferSchemaInput<TOutputSchema>, ORPCErrorConstructorMap<TErrorMap>, TMeta>): ProcedureBuilderWithInputOutput<MergedInitialContext<TInitialContext, UInContext, TCurrentContext>, MergedCurrentContext<TCurrentContext, UOutContext>, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Uses a middleware to modify the context or improve the pipeline.
     *
     * @info Supports both normal middleware and inline middleware implementations.
     * @info Pass second argument to map the input.
     * @note The current context must be satisfy middleware dependent-context
     * @see {@link https://orpc.unnoq.com/docs/middleware Middleware Docs}
     */
    'use'<UOutContext extends IntersectPick<TCurrentContext, UOutContext>, UInput, UInContext extends Context = TCurrentContext>(middleware: Middleware<UInContext | TCurrentContext, UOutContext, UInput, InferSchemaInput<TOutputSchema>, ORPCErrorConstructorMap<TErrorMap>, TMeta>, mapInput: MapInputMiddleware<InferSchemaOutput<TInputSchema>, UInput>): ProcedureBuilderWithInputOutput<MergedInitialContext<TInitialContext, UInContext, TCurrentContext>, MergedCurrentContext<TCurrentContext, UOutContext>, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Sets or updates the metadata.
     * The provided metadata is spared-merged with any existing metadata.
     *
     * @see {@link https://orpc.unnoq.com/docs/metadata Metadata Docs}
     */
    'meta'(meta: TMeta): ProcedureBuilderWithInputOutput<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Sets or updates the route definition.
     * The provided route is spared-merged with any existing route.
     * This option is typically relevant when integrating with OpenAPI.
     *
     * @see {@link https://orpc.unnoq.com/docs/openapi/routing OpenAPI Routing Docs}
     * @see {@link https://orpc.unnoq.com/docs/openapi/input-output-structure OpenAPI Input/Output Structure Docs}
     */
    'route'(route: Route): ProcedureBuilderWithInputOutput<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Defines the handler of the procedure.
     *
     * @see {@link https://orpc.unnoq.com/docs/procedure Procedure Docs}
     */
    'handler'(handler: ProcedureHandler<TCurrentContext, InferSchemaOutput<TInputSchema>, InferSchemaInput<TOutputSchema>, TErrorMap, TMeta>): DecoratedProcedure<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
}
interface RouterBuilder<TInitialContext extends Context, TCurrentContext extends Context, TErrorMap extends ErrorMap, TMeta extends Meta> {
    /**
     * This property holds the defined options.
     */
    '~orpc': EnhanceRouterOptions<TErrorMap>;
    /**
     * Adds type-safe custom errors.
     * The provided errors are spared-merged with any existing errors.
     *
     * @see {@link https://orpc.unnoq.com/docs/error-handling#type%E2%80%90safe-error-handling Type-Safe Error Handling Docs}
     */
    'errors'<U extends ErrorMap>(errors: U): RouterBuilder<TInitialContext, TCurrentContext, MergedErrorMap<TErrorMap, U>, TMeta>;
    /**
     * Uses a middleware to modify the context or improve the pipeline.
     *
     * @info Supports both normal middleware and inline middleware implementations.
     * @note The current context must be satisfy middleware dependent-context
     * @see {@link https://orpc.unnoq.com/docs/middleware Middleware Docs}
     */
    'use'<UOutContext extends IntersectPick<TCurrentContext, UOutContext>, UInContext extends Context = TCurrentContext>(middleware: Middleware<UInContext | TCurrentContext, UOutContext, unknown, unknown, ORPCErrorConstructorMap<TErrorMap>, TMeta>): RouterBuilder<MergedInitialContext<TInitialContext, UInContext, TCurrentContext>, MergedCurrentContext<TCurrentContext, UOutContext>, TErrorMap, TMeta>;
    /**
     * Prefixes all procedures in the router.
     * The provided prefix is post-appended to any existing router prefix.
     *
     * @note This option does not affect procedures that do not define a path in their route definition.
     *
     * @see {@link https://orpc.unnoq.com/docs/openapi/routing#route-prefixes OpenAPI Route Prefixes Docs}
     */
    'prefix'(prefix: HTTPPath): RouterBuilder<TInitialContext, TCurrentContext, TErrorMap, TMeta>;
    /**
     * Adds tags to all procedures in the router.
     * This helpful when you want to group procedures together in the OpenAPI specification.
     *
     * @see {@link https://orpc.unnoq.com/docs/openapi/openapi-specification#operation-metadata OpenAPI Operation Metadata Docs}
     */
    'tag'(...tags: string[]): RouterBuilder<TInitialContext, TCurrentContext, TErrorMap, TMeta>;
    /**
     * Applies all of the previously defined options to the specified router.
     *
     * @see {@link https://orpc.unnoq.com/docs/router#extending-router Extending Router Docs}
     */
    'router'<U extends Router<ContractRouter<TMeta>, TCurrentContext>>(router: U): EnhancedRouter<U, TInitialContext, TCurrentContext, TErrorMap>;
    /**
     * Create a lazy router
     * And applies all of the previously defined options to the specified router.
     *
     * @see {@link https://orpc.unnoq.com/docs/router#extending-router Extending Router Docs}
     */
    'lazy'<U extends Router<ContractRouter<TMeta>, TCurrentContext>>(loader: () => Promise<{
        default: U;
    }>): EnhancedRouter<Lazy<U>, TInitialContext, TCurrentContext, TErrorMap>;
}

interface DecoratedMiddleware<TInContext extends Context, TOutContext extends Context, TInput, TOutput, TErrorConstructorMap extends ORPCErrorConstructorMap<any>, TMeta extends Meta> extends Middleware<TInContext, TOutContext, TInput, TOutput, TErrorConstructorMap, TMeta> {
    /**
     * Change the expected input type by providing a map function.
     */
    mapInput<UInput>(map: MapInputMiddleware<UInput, TInput>): DecoratedMiddleware<TInContext, TOutContext, UInput, TOutput, TErrorConstructorMap, TMeta>;
    /**
     * Concatenates two middlewares.
     *
     * @info Pass second argument to map the input.
     * @see {@link https://orpc.unnoq.com/docs/middleware#concatenation Middleware Concatenation Docs}
     */
    concat<UOutContext extends IntersectPick<MergedCurrentContext<TInContext, TOutContext>, UOutContext>, UInput extends TInput, UInContext extends Context = MergedCurrentContext<TInContext, TOutContext>>(middleware: Middleware<UInContext | MergedCurrentContext<TInContext, TOutContext>, UOutContext, UInput, TOutput, TErrorConstructorMap, TMeta>): DecoratedMiddleware<MergedInitialContext<TInContext, UInContext, MergedCurrentContext<TInContext, TOutContext>>, MergedCurrentContext<TOutContext, UOutContext>, UInput, TOutput, TErrorConstructorMap, TMeta>;
    /**
     * Concatenates two middlewares.
     *
     * @info Pass second argument to map the input.
     * @see {@link https://orpc.unnoq.com/docs/middleware#concatenation Middleware Concatenation Docs}
     */
    concat<UOutContext extends IntersectPick<MergedCurrentContext<TInContext, TOutContext>, UOutContext>, UInput extends TInput, UMappedInput, UInContext extends Context = MergedCurrentContext<TInContext, TOutContext>>(middleware: Middleware<UInContext | MergedCurrentContext<TInContext, TOutContext>, UOutContext, UMappedInput, TOutput, TErrorConstructorMap, TMeta>, mapInput: MapInputMiddleware<UInput, UMappedInput>): DecoratedMiddleware<MergedInitialContext<TInContext, UInContext, MergedCurrentContext<TInContext, TOutContext>>, MergedCurrentContext<TOutContext, UOutContext>, UInput, TOutput, TErrorConstructorMap, TMeta>;
}
declare function decorateMiddleware<TInContext extends Context, TOutContext extends Context, TInput, TOutput, TErrorConstructorMap extends ORPCErrorConstructorMap<any>, TMeta extends Meta>(middleware: Middleware<TInContext, TOutContext, TInput, TOutput, TErrorConstructorMap, TMeta>): DecoratedMiddleware<TInContext, TOutContext, TInput, TOutput, TErrorConstructorMap, TMeta>;

interface BuilderConfig {
    initialInputValidationIndex?: number;
    initialOutputValidationIndex?: number;
    dedupeLeadingMiddlewares?: boolean;
}
interface BuilderDef<TInputSchema extends AnySchema, TOutputSchema extends AnySchema, TErrorMap extends ErrorMap, TMeta extends Meta> extends ContractProcedureDef<TInputSchema, TOutputSchema, TErrorMap, TMeta>, EnhanceRouterOptions<TErrorMap> {
    middlewares: readonly AnyMiddleware[];
    inputValidationIndex: number;
    outputValidationIndex: number;
    config: BuilderConfig;
}
declare class Builder<TInitialContext extends Context, TCurrentContext extends Context, TInputSchema extends AnySchema, TOutputSchema extends AnySchema, TErrorMap extends ErrorMap, TMeta extends Meta> {
    /**
     * This property holds the defined options.
     */
    '~orpc': BuilderDef<TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    constructor(def: BuilderDef<TInputSchema, TOutputSchema, TErrorMap, TMeta>);
    /**
     * Sets or overrides the config.
     *
     * @see {@link https://orpc.unnoq.com/docs/client/server-side#middlewares-order Middlewares Order Docs}
     * @see {@link https://orpc.unnoq.com/docs/best-practices/dedupe-middleware#configuration Dedupe Middleware Docs}
     */
    $config(config: BuilderConfig): Builder<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Set or override the initial context.
     *
     * @see {@link https://orpc.unnoq.com/docs/context Context Docs}
     */
    $context<U extends Context>(): Builder<U & Record<never, never>, U, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Sets or overrides the initial meta.
     *
     * @see {@link https://orpc.unnoq.com/docs/metadata Metadata Docs}
     */
    $meta<U extends Meta>(initialMeta: U): Builder<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, U & Record<never, never>>;
    /**
     * Sets or overrides the initial route.
     * This option is typically relevant when integrating with OpenAPI.
     *
     * @see {@link https://orpc.unnoq.com/docs/openapi/routing OpenAPI Routing Docs}
     * @see {@link https://orpc.unnoq.com/docs/openapi/input-output-structure OpenAPI Input/Output Structure Docs}
     */
    $route(initialRoute: Route): Builder<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Sets or overrides the initial input schema.
     *
     * @see {@link https://orpc.unnoq.com/docs/procedure#initial-configuration Initial Procedure Configuration Docs}
     */
    $input<U extends AnySchema>(initialInputSchema?: U): Builder<TInitialContext, TCurrentContext, U, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Creates a middleware.
     *
     * @see {@link https://orpc.unnoq.com/docs/middleware Middleware Docs}
     */
    middleware<UOutContext extends IntersectPick<TCurrentContext, UOutContext>, TInput, TOutput = any>(// = any here is important to make middleware can be used in any output by default
    middleware: Middleware<TInitialContext, UOutContext, TInput, TOutput, ORPCErrorConstructorMap<TErrorMap>, TMeta>): DecoratedMiddleware<TInitialContext, UOutContext, TInput, TOutput, any, TMeta>;
    /**
     * Adds type-safe custom errors.
     * The provided errors are spared-merged with any existing errors.
     *
     * @see {@link https://orpc.unnoq.com/docs/error-handling#type%E2%80%90safe-error-handling Type-Safe Error Handling Docs}
     */
    errors<U extends ErrorMap>(errors: U): Builder<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, MergedErrorMap<TErrorMap, U>, TMeta>;
    /**
     * Uses a middleware to modify the context or improve the pipeline.
     *
     * @info Supports both normal middleware and inline middleware implementations.
     * @note The current context must be satisfy middleware dependent-context
     * @see {@link https://orpc.unnoq.com/docs/middleware Middleware Docs}
     */
    use<UOutContext extends IntersectPick<TCurrentContext, UOutContext>, UInContext extends Context = TCurrentContext>(middleware: Middleware<UInContext | TCurrentContext, UOutContext, unknown, unknown, ORPCErrorConstructorMap<TErrorMap>, TMeta>): BuilderWithMiddlewares<MergedInitialContext<TInitialContext, UInContext, TCurrentContext>, MergedCurrentContext<TCurrentContext, UOutContext>, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Sets or updates the metadata.
     * The provided metadata is spared-merged with any existing metadata.
     *
     * @see {@link https://orpc.unnoq.com/docs/metadata Metadata Docs}
     */
    meta(meta: TMeta): ProcedureBuilder<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Sets or updates the route definition.
     * The provided route is spared-merged with any existing route.
     * This option is typically relevant when integrating with OpenAPI.
     *
     * @see {@link https://orpc.unnoq.com/docs/openapi/routing OpenAPI Routing Docs}
     * @see {@link https://orpc.unnoq.com/docs/openapi/input-output-structure OpenAPI Input/Output Structure Docs}
     */
    route(route: Route): ProcedureBuilder<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Defines the input validation schema.
     *
     * @see {@link https://orpc.unnoq.com/docs/procedure#input-output-validation Input Validation Docs}
     */
    input<USchema extends AnySchema>(schema: USchema): ProcedureBuilderWithInput<TInitialContext, TCurrentContext, USchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Defines the output validation schema.
     *
     * @see {@link https://orpc.unnoq.com/docs/procedure#input-output-validation Output Validation Docs}
     */
    output<USchema extends AnySchema>(schema: USchema): ProcedureBuilderWithOutput<TInitialContext, TCurrentContext, TInputSchema, USchema, TErrorMap, TMeta>;
    /**
     * Defines the handler of the procedure.
     *
     * @see {@link https://orpc.unnoq.com/docs/procedure Procedure Docs}
     */
    handler<UFuncOutput>(handler: ProcedureHandler<TCurrentContext, unknown, UFuncOutput, TErrorMap, TMeta>): DecoratedProcedure<TInitialContext, TCurrentContext, TInputSchema, Schema<UFuncOutput, UFuncOutput>, TErrorMap, TMeta>;
    /**
     * Prefixes all procedures in the router.
     * The provided prefix is post-appended to any existing router prefix.
     *
     * @note This option does not affect procedures that do not define a path in their route definition.
     *
     * @see {@link https://orpc.unnoq.com/docs/openapi/routing#route-prefixes OpenAPI Route Prefixes Docs}
     */
    prefix(prefix: HTTPPath): RouterBuilder<TInitialContext, TCurrentContext, TErrorMap, TMeta>;
    /**
     * Adds tags to all procedures in the router.
     * This helpful when you want to group procedures together in the OpenAPI specification.
     *
     * @see {@link https://orpc.unnoq.com/docs/openapi/openapi-specification#operation-metadata OpenAPI Operation Metadata Docs}
     */
    tag(...tags: string[]): RouterBuilder<TInitialContext, TCurrentContext, TErrorMap, TMeta>;
    /**
     * Applies all of the previously defined options to the specified router.
     *
     * @see {@link https://orpc.unnoq.com/docs/router#extending-router Extending Router Docs}
     */
    router<U extends Router<ContractRouter<TMeta>, TCurrentContext>>(router: U): EnhancedRouter<U, TInitialContext, TCurrentContext, TErrorMap>;
    /**
     * Create a lazy router
     * And applies all of the previously defined options to the specified router.
     *
     * @see {@link https://orpc.unnoq.com/docs/router#extending-router Extending Router Docs}
     */
    lazy<U extends Router<ContractRouter<TMeta>, TCurrentContext>>(loader: () => Promise<{
        default: U;
    }>): EnhancedRouter<Lazy<U>, TInitialContext, TCurrentContext, TErrorMap>;
}
declare const os: Builder<Record<never, never>, Record<never, never>, Schema<unknown, unknown>, Schema<unknown, unknown>, Record<never, never>, Record<never, never>>;

interface Config {
    initialInputValidationIndex: number;
    initialOutputValidationIndex: number;
    dedupeLeadingMiddlewares: boolean;
}
declare function fallbackConfig<T extends keyof Config>(key: T, value?: Config[T]): Config[T];

/**
 * Like `DecoratedProcedure`, but removed all method that can change the contract.
 */
interface ImplementedProcedure<TInitialContext extends Context, TCurrentContext extends Context, TInputSchema extends AnySchema, TOutputSchema extends AnySchema, TErrorMap extends ErrorMap, TMeta extends Meta> extends Procedure<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta> {
    /**
     * Uses a middleware to modify the context or improve the pipeline.
     *
     * @info Supports both normal middleware and inline middleware implementations.
     * @info Pass second argument to map the input.
     * @note The current context must be satisfy middleware dependent-context
     * @see {@link https://orpc.unnoq.com/docs/middleware Middleware Docs}
     */
    use<UOutContext extends IntersectPick<TCurrentContext, UOutContext>, UInContext extends Context = TCurrentContext>(middleware: Middleware<UInContext | TCurrentContext, UOutContext, InferSchemaOutput<TInputSchema>, InferSchemaInput<TOutputSchema>, ORPCErrorConstructorMap<TErrorMap>, TMeta>): ImplementedProcedure<MergedInitialContext<TInitialContext, UInContext, TCurrentContext>, MergedCurrentContext<TCurrentContext, UOutContext>, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Uses a middleware to modify the context or improve the pipeline.
     *
     * @info Supports both normal middleware and inline middleware implementations.
     * @info Pass second argument to map the input.
     * @note The current context must be satisfy middleware dependent-context
     * @see {@link https://orpc.unnoq.com/docs/middleware Middleware Docs}
     */
    use<UOutContext extends IntersectPick<TCurrentContext, UOutContext>, UInput, UInContext extends Context = TCurrentContext>(middleware: Middleware<UInContext | TCurrentContext, UOutContext, UInput, InferSchemaInput<TOutputSchema>, ORPCErrorConstructorMap<TErrorMap>, TMeta>, mapInput: MapInputMiddleware<InferSchemaOutput<TInputSchema>, UInput>): ImplementedProcedure<MergedInitialContext<TInitialContext, UInContext, TCurrentContext>, MergedCurrentContext<TCurrentContext, UOutContext>, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Make this procedure callable (works like a function while still being a procedure).
     *
     * @see {@link https://orpc.unnoq.com/docs/client/server-side Server-side Client Docs}
     */
    callable<TClientContext extends ClientContext>(...rest: MaybeOptionalOptions<CreateProcedureClientOptions<TInitialContext, TOutputSchema, TErrorMap, TMeta, TClientContext>>): ImplementedProcedure<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta> & ProcedureClient<TClientContext, TInputSchema, TOutputSchema, TErrorMap>;
    /**
     * Make this procedure compatible with server action.
     *
     * @see {@link https://orpc.unnoq.com/docs/server-action Server Action Docs}
     */
    actionable(...rest: MaybeOptionalOptions<CreateProcedureClientOptions<TInitialContext, TOutputSchema, TErrorMap, TMeta, Record<never, never>>>): ImplementedProcedure<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta> & ProcedureActionableClient<TInputSchema, TOutputSchema, TErrorMap>;
}
/**
 * Like `ProcedureBuilderWithoutHandler`, but removed all method that can change the contract.
 */
interface ProcedureImplementer<TInitialContext extends Context, TCurrentContext extends Context, TInputSchema extends AnySchema, TOutputSchema extends AnySchema, TErrorMap extends ErrorMap, TMeta extends Meta> {
    '~orpc': BuilderDef<TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Uses a middleware to modify the context or improve the pipeline.
     *
     * @info Supports both normal middleware and inline middleware implementations.
     * @info Pass second argument to map the input.
     * @note The current context must be satisfy middleware dependent-context
     * @see {@link https://orpc.unnoq.com/docs/middleware Middleware Docs}
     */
    'use'<UOutContext extends IntersectPick<TCurrentContext, UOutContext>, UInContext extends Context = TCurrentContext>(middleware: Middleware<UInContext | TCurrentContext, UOutContext, InferSchemaOutput<TInputSchema>, InferSchemaInput<TOutputSchema>, ORPCErrorConstructorMap<TErrorMap>, TMeta>): ProcedureImplementer<MergedInitialContext<TInitialContext, UInContext, TCurrentContext>, MergedCurrentContext<TCurrentContext, UOutContext>, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Uses a middleware to modify the context or improve the pipeline.
     *
     * @info Supports both normal middleware and inline middleware implementations.
     * @info Pass second argument to map the input.
     * @note The current context must be satisfy middleware dependent-context
     * @see {@link https://orpc.unnoq.com/docs/middleware Middleware Docs}
     */
    'use'<UOutContext extends IntersectPick<TCurrentContext, UOutContext>, UInput, UInContext extends Context = TCurrentContext>(middleware: Middleware<UInContext | TCurrentContext, UOutContext, UInput, InferSchemaInput<TOutputSchema>, ORPCErrorConstructorMap<TErrorMap>, TMeta>, mapInput: MapInputMiddleware<InferSchemaOutput<TInputSchema>, UInput>): ProcedureImplementer<MergedInitialContext<TInitialContext, UInContext, TCurrentContext>, MergedCurrentContext<TCurrentContext, UOutContext>, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Defines the handler of the procedure.
     *
     * @see {@link https://orpc.unnoq.com/docs/procedure Procedure Docs}
     */
    'handler'(handler: ProcedureHandler<TCurrentContext, InferSchemaOutput<TInputSchema>, InferSchemaInput<TOutputSchema>, TErrorMap, TMeta>): ImplementedProcedure<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
}

interface RouterImplementerWithMiddlewares<T extends AnyContractRouter, TInitialContext extends Context, TCurrentContext extends Context> {
    /**
     * Uses a middleware to modify the context or improve the pipeline.
     *
     * @info Supports both normal middleware and inline middleware implementations.
     * @note The current context must be satisfy middleware dependent-context
     * @see {@link https://orpc.unnoq.com/docs/middleware Middleware Docs}
     */
    use<UOutContext extends IntersectPick<TCurrentContext, UOutContext>, UInContext extends Context = TCurrentContext>(middleware: Middleware<UInContext | TCurrentContext, UOutContext, unknown, unknown, ORPCErrorConstructorMap<InferContractRouterErrorMap<T>>, InferContractRouterMeta<T>>): ImplementerInternalWithMiddlewares<T, MergedInitialContext<TInitialContext, UInContext, TCurrentContext>, MergedCurrentContext<TCurrentContext, UOutContext>>;
    /**
     * Applies all of the previously defined options to the specified router.
     * And enforces the router match the contract.
     *
     * @see {@link https://orpc.unnoq.com/docs/router#extending-router Extending Router Docs}
     */
    router<U extends Router<T, TCurrentContext>>(router: U): EnhancedRouter<U, TInitialContext, TCurrentContext, Record<never, never>>;
    /**
     * Create a lazy router
     * And applies all of the previously defined options to the specified router.
     * And enforces the router match the contract.
     *
     * @see {@link https://orpc.unnoq.com/docs/router#extending-router Extending Router Docs}
     */
    lazy<U extends Router<T, TInitialContext>>(loader: () => Promise<{
        default: U;
    }>): EnhancedRouter<Lazy<U>, TInitialContext, TCurrentContext, Record<never, never>>;
}
type ImplementerInternalWithMiddlewares<TContract extends AnyContractRouter, TInitialContext extends Context, TCurrentContext extends Context> = TContract extends ContractProcedure<infer UInputSchema, infer UOutputSchema, infer UErrorMap, infer UMeta> ? ProcedureImplementer<TInitialContext, TCurrentContext, UInputSchema, UOutputSchema, UErrorMap, UMeta> : RouterImplementerWithMiddlewares<TContract, TInitialContext, TCurrentContext> & {
    [K in keyof TContract]: TContract[K] extends AnyContractRouter ? ImplementerInternalWithMiddlewares<TContract[K], TInitialContext, TCurrentContext> : never;
};

interface RouterImplementer<T extends AnyContractRouter, TInitialContext extends Context, TCurrentContext extends Context> {
    /**
     * Creates a middleware.
     *
     * @see {@link https://orpc.unnoq.com/docs/middleware Middleware Docs}
     */
    middleware<UOutContext extends IntersectPick<TCurrentContext, UOutContext>, TInput, TOutput = any>(// = any here is important to make middleware can be used in any output by default
    middleware: Middleware<TInitialContext, UOutContext, TInput, TOutput, ORPCErrorConstructorMap<InferContractRouterErrorMap<T>>, InferContractRouterMeta<T>>): DecoratedMiddleware<TInitialContext, UOutContext, TInput, TOutput, any, InferContractRouterMeta<T>>;
    /**
     * Uses a middleware to modify the context or improve the pipeline.
     *
     * @info Supports both normal middleware and inline middleware implementations.
     * @note The current context must be satisfy middleware dependent-context
     * @see {@link https://orpc.unnoq.com/docs/middleware Middleware Docs}
     */
    use<UOutContext extends IntersectPick<TCurrentContext, UOutContext>, UInContext extends Context = TCurrentContext>(middleware: Middleware<UInContext | TCurrentContext, UOutContext, unknown, unknown, ORPCErrorConstructorMap<InferContractRouterErrorMap<T>>, InferContractRouterMeta<T>>): ImplementerInternalWithMiddlewares<T, MergedInitialContext<TInitialContext, UInContext, TCurrentContext>, MergedCurrentContext<TCurrentContext, UOutContext>>;
    /**
     * Applies all of the previously defined options to the specified router.
     * And enforces the router match the contract.
     *
     * @see {@link https://orpc.unnoq.com/docs/router#extending-router Extending Router Docs}
     */
    router<U extends Router<T, TCurrentContext>>(router: U): EnhancedRouter<U, TInitialContext, TCurrentContext, Record<never, never>>;
    /**
     * Create a lazy router
     * And applies all of the previously defined options to the specified router.
     * And enforces the router match the contract.
     *
     * @see {@link https://orpc.unnoq.com/docs/router#extending-router Extending Router Docs}
     */
    lazy<U extends Router<T, TCurrentContext>>(loader: () => Promise<{
        default: U;
    }>): EnhancedRouter<Lazy<U>, TInitialContext, TCurrentContext, Record<never, never>>;
}
type ImplementerInternal<TContract extends AnyContractRouter, TInitialContext extends Context, TCurrentContext extends Context> = TContract extends ContractProcedure<infer UInputSchema, infer UOutputSchema, infer UErrorMap, infer UMeta> ? ProcedureImplementer<TInitialContext, TCurrentContext, UInputSchema, UOutputSchema, UErrorMap, UMeta> : RouterImplementer<TContract, TInitialContext, TCurrentContext> & {
    [K in keyof TContract]: TContract[K] extends AnyContractRouter ? ImplementerInternal<TContract[K], TInitialContext, TCurrentContext> : never;
};
declare function implementerInternal<T extends AnyContractRouter, TInitialContext extends Context, TCurrentContext extends Context>(contract: T, config: BuilderConfig, middlewares: AnyMiddleware[]): ImplementerInternal<T, TInitialContext, TCurrentContext>;
type Implementer<TContract extends AnyContractRouter, TInitialContext extends Context, TCurrentContext extends Context> = {
    /**
     * Set or override the initial context.
     *
     * @see {@link https://orpc.unnoq.com/docs/context Context Docs}
     */
    $context<U extends Context>(): Implementer<TContract, U & Record<never, never>, U>;
    /**
     * Sets or overrides the config.
     *
     * @see {@link https://orpc.unnoq.com/docs/client/server-side#middlewares-order Middlewares Order Docs}
     * @see {@link https://orpc.unnoq.com/docs/best-practices/dedupe-middleware#configuration Dedupe Middleware Docs}
     */
    $config(config: BuilderConfig): Implementer<TContract, TInitialContext, TCurrentContext>;
} & ImplementerInternal<TContract, TInitialContext, TCurrentContext>;
declare function implement<T extends AnyContractRouter, TContext extends Context = Record<never, never>>(contract: T, config?: BuilderConfig): Implementer<T, TContext, TContext>;

/**
 * Help RPCLink automatically send requests using the specified HTTP method in the router.
 */
declare function inferRPCMethodFromRouter(router: AnyRouter): (options: unknown, path: readonly string[]) => Promise<Exclude<HTTPMethod, 'HEAD'>>;

declare function isStartWithMiddlewares(middlewares: readonly AnyMiddleware[], compare: readonly AnyMiddleware[]): boolean;
declare function mergeMiddlewares(first: readonly AnyMiddleware[], second: readonly AnyMiddleware[], options: {
    dedupeLeading: boolean;
}): readonly AnyMiddleware[];
declare function addMiddleware(middlewares: readonly AnyMiddleware[], addition: AnyMiddleware): AnyMiddleware[];

declare function createAssertedLazyProcedure(lazied: Lazy<any>): Lazy<AnyProcedure>;
/**
 * Create a new procedure that ensure the contract is applied to the procedure.
 */
declare function createContractedProcedure(procedure: AnyProcedure, contract: AnyContractProcedure): AnyProcedure;
/**
 * Directly call a procedure without creating a client.
 *
 * @example
 * ```ts
 * const output = await call(getting, 'input')
 * const output = await call(getting, 'input', { context: { db: 'postgres' } })
 * ```
 *
 */
declare function call<TInitialContext extends Context, TInputSchema extends AnySchema, TOutputSchema extends AnySchema, TErrorMap extends ErrorMap, TMeta extends Meta>(procedure: Lazyable<Procedure<TInitialContext, any, TInputSchema, TOutputSchema, TErrorMap, TMeta>>, input: InferSchemaInput<TInputSchema>, ...rest: MaybeOptionalOptions<CreateProcedureClientOptions<TInitialContext, TOutputSchema, TErrorMap, TMeta, Record<never, never>> & Omit<ClientOptions<Record<never, never>>, 'context'>>): ClientPromiseResult<InferSchemaOutput<TOutputSchema>, ErrorFromErrorMap<TErrorMap>>;

type RouterClient<TRouter extends AnyRouter, TClientContext extends ClientContext = Record<never, never>> = TRouter extends Procedure<any, any, infer UInputSchema, infer UOutputSchema, infer UErrorMap, any> ? ProcedureClient<TClientContext, UInputSchema, UOutputSchema, UErrorMap> : {
    [K in keyof TRouter]: TRouter[K] extends Lazyable<infer U extends AnyRouter> ? RouterClient<U, TClientContext> : never;
};
/**
 * Create Server-side client from a router.
 *
 * @see {@link https://orpc.unnoq.com/docs/client/server-side Server-side Client Docs}
 */
declare function createRouterClient<T extends AnyRouter, TClientContext extends ClientContext>(router: Lazyable<T | undefined>, ...rest: MaybeOptionalOptions<CreateProcedureClientOptions<InferRouterInitialContext<T>, Schema<unknown, unknown>, ErrorMap, Meta, TClientContext>>): RouterClient<T, TClientContext>;

declare function setHiddenRouterContract<T extends Lazyable<AnyRouter>>(router: T, contract: AnyContractRouter): T;
declare function getHiddenRouterContract(router: Lazyable<AnyRouter | AnyContractRouter>): AnyContractRouter | undefined;

export { AnyMiddleware, AnyProcedure, AnyRouter, Builder, Context, CreateProcedureClientOptions, DecoratedProcedure, EnhanceRouterOptions, EnhancedRouter, InferRouterInitialContext, Lazy, Lazyable, MapInputMiddleware, MergedCurrentContext, MergedInitialContext, Middleware, ORPCErrorConstructorMap, Procedure, ProcedureClient, ProcedureHandler, Router, addMiddleware, call, createActionableClient, createAssertedLazyProcedure, createContractedProcedure, createRouterClient, decorateMiddleware, fallbackConfig, getHiddenRouterContract, implement, implementerInternal, inferRPCMethodFromRouter, isStartWithMiddlewares, mergeMiddlewares, os, setHiddenRouterContract };
export type { ActionableClient, ActionableClientRest, ActionableClientResult, ActionableError, BuilderConfig, BuilderDef, BuilderWithMiddlewares, Config, DecoratedMiddleware, ImplementedProcedure, Implementer, ImplementerInternal, ImplementerInternalWithMiddlewares, ProcedureActionableClient, ProcedureBuilder, ProcedureBuilderWithInput, ProcedureBuilderWithInputOutput, ProcedureBuilderWithOutput, ProcedureImplementer, RouterBuilder, RouterClient, RouterImplementer, RouterImplementerWithMiddlewares, UnactionableError };
