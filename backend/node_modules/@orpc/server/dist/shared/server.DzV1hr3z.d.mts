import { ErrorMap, EnhanceRouteOptions, MergedErrorMap, AnyContractRouter, AnyContractProcedure } from '@orpc/contract';
import { a as AnyMiddleware, L as Lazyable, b as AnyRouter, C as Context, c as Lazy, A as AnyProcedure, P as Procedure, M as MergedInitialContext } from './server.B4BGqy3Y.mjs';

declare function getRouter<T extends Lazyable<AnyRouter | undefined>>(router: T, path: readonly string[]): T extends Lazy<any> ? Lazy<AnyRouter | undefined> : Lazyable<AnyRouter | undefined>;
type AccessibleLazyRouter<T extends Lazyable<AnyRouter | undefined>> = T extends Lazy<infer U extends AnyRouter | undefined | Lazy<AnyRouter | undefined>> ? AccessibleLazyRouter<U> : T extends AnyProcedure | undefined ? Lazy<T> : Lazy<T> & {
    [K in keyof T]: T[K] extends Lazyable<AnyRouter> ? AccessibleLazyRouter<T[K]> : never;
};
declare function createAccessibleLazyRouter<T extends Lazy<AnyRouter | undefined>>(lazied: T): AccessibleLazyRouter<T>;
type EnhancedRouter<T extends Lazyable<AnyRouter>, TInitialContext extends Context, TCurrentContext extends Context, TErrorMap extends ErrorMap> = T extends Lazy<infer U extends AnyRouter> ? AccessibleLazyRouter<EnhancedRouter<U, TInitialContext, TCurrentContext, TErrorMap>> : T extends Procedure<infer UInitialContext, infer UCurrentContext, infer UInputSchema, infer UOutputSchema, infer UErrorMap, infer UMeta> ? Procedure<MergedInitialContext<TInitialContext, UInitialContext, TCurrentContext>, UCurrentContext, UInputSchema, UOutputSchema, MergedErrorMap<TErrorMap, UErrorMap>, UMeta> : {
    [K in keyof T]: T[K] extends Lazyable<AnyRouter> ? EnhancedRouter<T[K], TInitialContext, TCurrentContext, TErrorMap> : never;
};
interface EnhanceRouterOptions<TErrorMap extends ErrorMap> extends EnhanceRouteOptions {
    middlewares: readonly AnyMiddleware[];
    errorMap: TErrorMap;
    dedupeLeadingMiddlewares: boolean;
}
declare function enhanceRouter<T extends Lazyable<AnyRouter>, TInitialContext extends Context, TCurrentContext extends Context, TErrorMap extends ErrorMap>(router: T, options: EnhanceRouterOptions<TErrorMap>): EnhancedRouter<T, TInitialContext, TCurrentContext, TErrorMap>;
interface TraverseContractProceduresOptions {
    router: AnyContractRouter | AnyRouter;
    path: readonly string[];
}
interface TraverseContractProcedureCallbackOptions {
    contract: AnyContractProcedure | AnyProcedure;
    path: readonly string[];
}
/**
 * @deprecated Use `TraverseContractProcedureCallbackOptions` instead.
 */
type ContractProcedureCallbackOptions = TraverseContractProcedureCallbackOptions;
interface LazyTraverseContractProceduresOptions {
    router: Lazy<AnyRouter>;
    path: readonly string[];
}
declare function traverseContractProcedures(options: TraverseContractProceduresOptions, callback: (options: TraverseContractProcedureCallbackOptions) => void, lazyOptions?: LazyTraverseContractProceduresOptions[]): LazyTraverseContractProceduresOptions[];
declare function resolveContractProcedures(options: TraverseContractProceduresOptions, callback: (options: TraverseContractProcedureCallbackOptions) => void): Promise<void>;
type UnlaziedRouter<T extends AnyRouter> = T extends AnyProcedure ? T : {
    [K in keyof T]: T[K] extends Lazyable<infer U extends AnyRouter> ? UnlaziedRouter<U> : never;
};
declare function unlazyRouter<T extends AnyRouter>(router: T): Promise<UnlaziedRouter<T>>;

export { createAccessibleLazyRouter as c, enhanceRouter as e, getRouter as g, resolveContractProcedures as r, traverseContractProcedures as t, unlazyRouter as u };
export type { AccessibleLazyRouter as A, ContractProcedureCallbackOptions as C, EnhanceRouterOptions as E, LazyTraverseContractProceduresOptions as L, TraverseContractProcedureCallbackOptions as T, UnlaziedRouter as U, EnhancedRouter as a, TraverseContractProceduresOptions as b };
