import { isContractProcedure, validateORPCError, ValidationError, mergePrefix, mergeErrorMap, enhanceRoute } from '@orpc/contract';
import { resolveMaybeOptionalOptions, toArray, value, runWithSpan, intercept, isAsyncIteratorObject, overlayProxy, asyncIteratorWithSpan } from '@orpc/shared';
import { ORPCError, mapEventIterator } from '@orpc/client';
import { HibernationEventIterator } from '@orpc/standard-server';

const LAZY_SYMBOL = Symbol("ORPC_LAZY_SYMBOL");
function lazy(loader, meta = {}) {
  return {
    [LAZY_SYMBOL]: {
      loader,
      meta
    }
  };
}
function isLazy(item) {
  return (typeof item === "object" || typeof item === "function") && item !== null && LAZY_SYMBOL in item;
}
function getLazyMeta(lazied) {
  return lazied[LAZY_SYMBOL].meta;
}
function unlazy(lazied) {
  return isLazy(lazied) ? lazied[LAZY_SYMBOL].loader() : Promise.resolve({ default: lazied });
}

function isStartWithMiddlewares(middlewares, compare) {
  if (compare.length > middlewares.length) {
    return false;
  }
  for (let i = 0; i < middlewares.length; i++) {
    if (compare[i] === void 0) {
      return true;
    }
    if (middlewares[i] !== compare[i]) {
      return false;
    }
  }
  return true;
}
function mergeMiddlewares(first, second, options) {
  if (options.dedupeLeading && isStartWithMiddlewares(second, first)) {
    return second;
  }
  return [...first, ...second];
}
function addMiddleware(middlewares, addition) {
  return [...middlewares, addition];
}

class Procedure {
  /**
   * This property holds the defined options.
   */
  "~orpc";
  constructor(def) {
    this["~orpc"] = def;
  }
}
function isProcedure(item) {
  if (item instanceof Procedure) {
    return true;
  }
  return isContractProcedure(item) && "middlewares" in item["~orpc"] && "inputValidationIndex" in item["~orpc"] && "outputValidationIndex" in item["~orpc"] && "handler" in item["~orpc"];
}

function mergeCurrentContext(context, other) {
  return { ...context, ...other };
}

function createORPCErrorConstructorMap(errors) {
  const proxy = new Proxy(errors, {
    get(target, code) {
      if (typeof code !== "string") {
        return Reflect.get(target, code);
      }
      const item = (...rest) => {
        const options = resolveMaybeOptionalOptions(rest);
        const config = errors[code];
        return new ORPCError(code, {
          defined: Boolean(config),
          status: config?.status,
          message: options.message ?? config?.message,
          data: options.data,
          cause: options.cause
        });
      };
      return item;
    }
  });
  return proxy;
}

function middlewareOutputFn(output) {
  return { output, context: {} };
}

function createProcedureClient(lazyableProcedure, ...rest) {
  const options = resolveMaybeOptionalOptions(rest);
  return async (...[input, callerOptions]) => {
    const path = toArray(options.path);
    const { default: procedure } = await unlazy(lazyableProcedure);
    const clientContext = callerOptions?.context ?? {};
    const context = await value(options.context ?? {}, clientContext);
    const errors = createORPCErrorConstructorMap(procedure["~orpc"].errorMap);
    const validateError = async (e) => {
      if (e instanceof ORPCError) {
        return await validateORPCError(procedure["~orpc"].errorMap, e);
      }
      return e;
    };
    try {
      const output = await runWithSpan(
        { name: "call_procedure", signal: callerOptions?.signal },
        (span) => {
          span?.setAttribute("procedure.path", [...path]);
          return intercept(
            toArray(options.interceptors),
            {
              context,
              input,
              // input only optional when it undefinable so we can safely cast it
              errors,
              path,
              procedure,
              signal: callerOptions?.signal,
              lastEventId: callerOptions?.lastEventId
            },
            (interceptorOptions) => executeProcedureInternal(interceptorOptions.procedure, interceptorOptions)
          );
        }
      );
      if (isAsyncIteratorObject(output)) {
        if (output instanceof HibernationEventIterator) {
          return output;
        }
        return overlayProxy(output, mapEventIterator(
          asyncIteratorWithSpan(
            { name: "consume_event_iterator_output", signal: callerOptions?.signal },
            output
          ),
          {
            value: (v) => v,
            error: (e) => validateError(e)
          }
        ));
      }
      return output;
    } catch (e) {
      throw await validateError(e);
    }
  };
}
async function validateInput(procedure, input) {
  const schema = procedure["~orpc"].inputSchema;
  if (!schema) {
    return input;
  }
  return runWithSpan(
    { name: "validate_input" },
    async () => {
      const result = await schema["~standard"].validate(input);
      if (result.issues) {
        throw new ORPCError("BAD_REQUEST", {
          message: "Input validation failed",
          data: {
            issues: result.issues
          },
          cause: new ValidationError({
            message: "Input validation failed",
            issues: result.issues,
            data: input
          })
        });
      }
      return result.value;
    }
  );
}
async function validateOutput(procedure, output) {
  const schema = procedure["~orpc"].outputSchema;
  if (!schema) {
    return output;
  }
  return runWithSpan(
    { name: "validate_output" },
    async () => {
      const result = await schema["~standard"].validate(output);
      if (result.issues) {
        throw new ORPCError("INTERNAL_SERVER_ERROR", {
          message: "Output validation failed",
          cause: new ValidationError({
            message: "Output validation failed",
            issues: result.issues,
            data: output
          })
        });
      }
      return result.value;
    }
  );
}
async function executeProcedureInternal(procedure, options) {
  const middlewares = procedure["~orpc"].middlewares;
  const inputValidationIndex = Math.min(Math.max(0, procedure["~orpc"].inputValidationIndex), middlewares.length);
  const outputValidationIndex = Math.min(Math.max(0, procedure["~orpc"].outputValidationIndex), middlewares.length);
  const next = async (index, context, input) => {
    let currentInput = input;
    if (index === inputValidationIndex) {
      currentInput = await validateInput(procedure, currentInput);
    }
    const mid = middlewares[index];
    const output = mid ? await runWithSpan(
      { name: `middleware.${mid.name}`, signal: options.signal },
      async (span) => {
        span?.setAttribute("middleware.index", index);
        span?.setAttribute("middleware.name", mid.name);
        const result = await mid({
          ...options,
          context,
          next: async (...[nextOptions]) => {
            const nextContext = nextOptions?.context ?? {};
            return {
              output: await next(index + 1, mergeCurrentContext(context, nextContext), currentInput),
              context: nextContext
            };
          }
        }, currentInput, middlewareOutputFn);
        return result.output;
      }
    ) : await runWithSpan(
      { name: "handler", signal: options.signal },
      () => procedure["~orpc"].handler({ ...options, context, input: currentInput })
    );
    if (index === outputValidationIndex) {
      return await validateOutput(procedure, output);
    }
    return output;
  };
  return next(0, options.context, options.input);
}

const HIDDEN_ROUTER_CONTRACT_SYMBOL = Symbol("ORPC_HIDDEN_ROUTER_CONTRACT");
function setHiddenRouterContract(router, contract) {
  return new Proxy(router, {
    get(target, key) {
      if (key === HIDDEN_ROUTER_CONTRACT_SYMBOL) {
        return contract;
      }
      return Reflect.get(target, key);
    }
  });
}
function getHiddenRouterContract(router) {
  return router[HIDDEN_ROUTER_CONTRACT_SYMBOL];
}

function getRouter(router, path) {
  let current = router;
  for (let i = 0; i < path.length; i++) {
    const segment = path[i];
    if (!current) {
      return void 0;
    }
    if (isProcedure(current)) {
      return void 0;
    }
    if (!isLazy(current)) {
      current = current[segment];
      continue;
    }
    const lazied = current;
    const rest = path.slice(i);
    return lazy(async () => {
      const unwrapped = await unlazy(lazied);
      const next = getRouter(unwrapped.default, rest);
      return unlazy(next);
    }, getLazyMeta(lazied));
  }
  return current;
}
function createAccessibleLazyRouter(lazied) {
  const recursive = new Proxy(lazied, {
    get(target, key) {
      if (typeof key !== "string") {
        return Reflect.get(target, key);
      }
      const next = getRouter(lazied, [key]);
      return createAccessibleLazyRouter(next);
    }
  });
  return recursive;
}
function enhanceRouter(router, options) {
  if (isLazy(router)) {
    const laziedMeta = getLazyMeta(router);
    const enhancedPrefix = laziedMeta?.prefix ? mergePrefix(options.prefix, laziedMeta?.prefix) : options.prefix;
    const enhanced2 = lazy(async () => {
      const { default: unlaziedRouter } = await unlazy(router);
      const enhanced3 = enhanceRouter(unlaziedRouter, options);
      return unlazy(enhanced3);
    }, {
      ...laziedMeta,
      prefix: enhancedPrefix
    });
    const accessible = createAccessibleLazyRouter(enhanced2);
    return accessible;
  }
  if (isProcedure(router)) {
    const newMiddlewares = mergeMiddlewares(options.middlewares, router["~orpc"].middlewares, { dedupeLeading: options.dedupeLeadingMiddlewares });
    const newMiddlewareAdded = newMiddlewares.length - router["~orpc"].middlewares.length;
    const enhanced2 = new Procedure({
      ...router["~orpc"],
      route: enhanceRoute(router["~orpc"].route, options),
      errorMap: mergeErrorMap(options.errorMap, router["~orpc"].errorMap),
      middlewares: newMiddlewares,
      inputValidationIndex: router["~orpc"].inputValidationIndex + newMiddlewareAdded,
      outputValidationIndex: router["~orpc"].outputValidationIndex + newMiddlewareAdded
    });
    return enhanced2;
  }
  const enhanced = {};
  for (const key in router) {
    enhanced[key] = enhanceRouter(router[key], options);
  }
  return enhanced;
}
function traverseContractProcedures(options, callback, lazyOptions = []) {
  let currentRouter = options.router;
  const hiddenContract = getHiddenRouterContract(options.router);
  if (hiddenContract !== void 0) {
    currentRouter = hiddenContract;
  }
  if (isLazy(currentRouter)) {
    lazyOptions.push({
      router: currentRouter,
      path: options.path
    });
  } else if (isContractProcedure(currentRouter)) {
    callback({
      contract: currentRouter,
      path: options.path
    });
  } else {
    for (const key in currentRouter) {
      traverseContractProcedures(
        {
          router: currentRouter[key],
          path: [...options.path, key]
        },
        callback,
        lazyOptions
      );
    }
  }
  return lazyOptions;
}
async function resolveContractProcedures(options, callback) {
  const pending = [options];
  for (const options2 of pending) {
    const lazyOptions = traverseContractProcedures(options2, callback);
    for (const options3 of lazyOptions) {
      const { default: router } = await unlazy(options3.router);
      pending.push({
        router,
        path: options3.path
      });
    }
  }
}
async function unlazyRouter(router) {
  if (isProcedure(router)) {
    return router;
  }
  const unlazied = {};
  for (const key in router) {
    const item = router[key];
    const { default: unlaziedRouter } = await unlazy(item);
    unlazied[key] = await unlazyRouter(unlaziedRouter);
  }
  return unlazied;
}

function createAssertedLazyProcedure(lazied) {
  const lazyProcedure = lazy(async () => {
    const { default: maybeProcedure } = await unlazy(lazied);
    if (!isProcedure(maybeProcedure)) {
      throw new Error(`
            Expected a lazy<procedure> but got lazy<unknown>.
            This should be caught by TypeScript compilation.
            Please report this issue if this makes you feel uncomfortable.
        `);
    }
    return { default: maybeProcedure };
  }, getLazyMeta(lazied));
  return lazyProcedure;
}
function createContractedProcedure(procedure, contract) {
  return new Procedure({
    ...procedure["~orpc"],
    errorMap: contract["~orpc"].errorMap,
    route: contract["~orpc"].route,
    meta: contract["~orpc"].meta
  });
}
function call(procedure, input, ...rest) {
  const options = resolveMaybeOptionalOptions(rest);
  return createProcedureClient(procedure, options)(input, options);
}

export { LAZY_SYMBOL as L, Procedure as P, createContractedProcedure as a, addMiddleware as b, createProcedureClient as c, isLazy as d, enhanceRouter as e, createAssertedLazyProcedure as f, getRouter as g, createORPCErrorConstructorMap as h, isProcedure as i, getLazyMeta as j, middlewareOutputFn as k, lazy as l, mergeCurrentContext as m, isStartWithMiddlewares as n, mergeMiddlewares as o, call as p, getHiddenRouterContract as q, createAccessibleLazyRouter as r, setHiddenRouterContract as s, traverseContractProcedures as t, unlazy as u, resolveContractProcedures as v, unlazyRouter as w };
